<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Co-Scientist - Experiment Tree</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }

        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 100;
        }

        #header h1 {
            font-size: 18px;
            font-weight: 500;
            color: #e94560;
        }

        #header .hypothesis {
            margin-left: 30px;
            font-size: 14px;
            color: #888;
            max-width: 500px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #stage-nav {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            height: 50px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 10px;
            z-index: 99;
        }

        .stage-btn {
            padding: 8px 16px;
            border: 1px solid #0f3460;
            border-radius: 4px;
            background: transparent;
            color: #888;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .stage-btn:hover {
            border-color: #e94560;
            color: #e94560;
        }

        .stage-btn.active {
            background: #e94560;
            border-color: #e94560;
            color: white;
        }

        .stage-btn.completed {
            border-color: #4ecca3;
            color: #4ecca3;
        }

        .stage-btn.loop-back {
            border-color: #ffc107;
            color: #ffc107;
        }

        #canvas-container {
            position: fixed;
            top: 110px;
            left: 0;
            right: 300px;
            bottom: 0;
        }

        #details-panel {
            position: fixed;
            top: 110px;
            right: 0;
            width: 300px;
            bottom: 0;
            background: #16213e;
            border-left: 1px solid #0f3460;
            padding: 20px;
            overflow-y: auto;
        }

        #details-panel h2 {
            font-size: 14px;
            color: #e94560;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #details-panel .section {
            margin-bottom: 20px;
        }

        #details-panel .label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        #details-panel .value {
            font-size: 13px;
            color: #ccc;
            line-height: 1.5;
        }

        #details-panel .code {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 11px;
            background: #0d1117;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }

        #details-panel .metric {
            display: inline-block;
            padding: 4px 8px;
            background: #4ecca3;
            color: #1a1a2e;
            border-radius: 4px;
            font-weight: 600;
            font-size: 14px;
        }

        #details-panel .metric.buggy {
            background: #e94560;
            color: white;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .empty-state h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #888;
        }

        #legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #0f3460;
            z-index: 50;
        }

        #legend .item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        #legend .item:last-child {
            margin-bottom: 0;
        }

        #legend .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        #legend .dot.success { background: #4ecca3; }
        #legend .dot.buggy { background: #e94560; }
        #legend .dot.pending { background: #888; }
    </style>
</head>
<body>
    <div id="header">
        <h1>AI Co-Scientist</h1>
        <span class="hypothesis" id="hypothesis-display"></span>
    </div>

    <div id="stage-nav">
        <button class="stage-btn" data-stage="0">Stage 0: Literature</button>
        <button class="stage-btn" data-stage="1">Stage 1: Hypothesis</button>
        <button class="stage-btn" data-stage="2">Stage 2: Design</button>
        <button class="stage-btn" data-stage="3">Stage 3: Experiment</button>
        <button class="stage-btn" data-stage="4">Stage 4: Validation</button>
    </div>

    <div id="canvas-container"></div>

    <div id="details-panel">
        <h2>Node Details</h2>
        <div id="node-details">
            <div class="empty-state">
                <h3>No Node Selected</h3>
                <p>Click a node to view details</p>
            </div>
        </div>
    </div>

    <div id="legend">
        <div class="item"><span class="dot success"></span> Success</div>
        <div class="item"><span class="dot buggy"></span> Buggy / Failed</div>
        <div class="item"><span class="dot pending"></span> Pending</div>
    </div>

    <script>
        // AI Co-Scientist Visualization Script
const TREE_DATA = {
  "project_path": "/Users/bmo/make-co-scientist-skill/memory-test-project",
  "hypothesis": {
    "primary": "H1 (Translation): Agentic retrieval (LME+) will achieve QA accuracy within 5% of static retrieval (LME best = 72%), but at 2-3x higher latency/cost.",
    "secondary": [
      "H2 (Method Ranking): Simple filesystem access will outperform specialized MCP memory tools in agentic contexts.",
      "H3 (Retrieval Gating): Memory tool effectiveness is modulated by retrieval quality\u2014tools provide no benefit when retrieval fails (Recall@10=0) or succeeds excellently (Recall@10>0.8)."
    ],
    "success_criteria": "LME+ accuracy >= 67%",
    "failure_criteria": "LME+ accuracy < 67% OR cost > 5x static"
  },
  "variables": {
    "independent": {
      "memory_method": [
        "Built-in MCP",
        "Stella v5 MCP",
        "Filesystem",
        "Compression",
        "Oracle"
      ],
      "filesystem_access": [
        true,
        false
      ]
    },
    "dependent": [
      "qa_accuracy",
      "time_seconds",
      "tokens",
      "cost_usd",
      "tool_calls"
    ],
    "control": {
      "agent": "ReAct",
      "llm": "GPT-4o",
      "judge": "GPT-4o",
      "dataset": "LongMemEval_S",
      "seed": 42
    }
  },
  "stage_history": [
    {
      "stage": 0,
      "iteration": 1,
      "tree_file": "stage_0_iter_1.json",
      "started": "2026-01-22T14:41:49.303292",
      "completed": "2026-01-22T14:41:53.124072",
      "outcome": "success"
    },
    {
      "stage": 1,
      "iteration": 1,
      "tree_file": "stage_1_iter_1.json",
      "started": "2026-01-22T15:03:41.798183",
      "completed": "2026-01-22T15:04:35.002903",
      "outcome": "success"
    },
    {
      "stage": 2,
      "iteration": 1,
      "tree_file": "stage_2_iter_1.json",
      "started": "2026-01-22T15:05:06.306940",
      "completed": "2026-01-22T15:09:10.111670",
      "outcome": "success"
    },
    {
      "stage": 3,
      "iteration": 1,
      "tree_file": "stage_3_iter_1.json",
      "started": "2026-01-22T15:09:52.338740",
      "completed": "2026-01-22T16:37:44.993417",
      "outcome": "success"
    },
    {
      "stage": 4,
      "iteration": 1,
      "tree_file": "stage_4_iter_1.json",
      "started": "2026-01-22T16:38:43.082185",
      "completed": "2026-01-22T16:40:13.632505",
      "outcome": "success"
    }
  ],
  "trees": {
    "stage_2_iter_1": {
      "stage": 2,
      "iteration": 1,
      "nodes": {},
      "root_ids": [],
      "created_at": "2026-01-22T15:05:06.306935",
      "completed_at": "2026-01-22T15:09:10.111664",
      "outcome": "success"
    },
    "stage_1_iter_1": {
      "stage": 1,
      "iteration": 1,
      "nodes": {},
      "root_ids": [],
      "created_at": "2026-01-22T15:03:41.798177",
      "completed_at": "2026-01-22T15:04:35.002898",
      "outcome": "success"
    },
    "stage_4_iter_1": {
      "stage": 4,
      "iteration": 1,
      "nodes": {},
      "root_ids": [],
      "created_at": "2026-01-22T16:38:43.082177",
      "completed_at": "2026-01-22T16:40:13.632497",
      "outcome": "success"
    },
    "stage_3_iter_1": {
      "stage": 3,
      "iteration": 1,
      "nodes": {
        "node-66c5275a": {
          "id": "node-66c5275a",
          "parent_id": null,
          "children": [
            "node-0a5b6b5d",
            "node-ebf73f5f",
            "node-b839c49c"
          ],
          "step": 1,
          "stage": 3,
          "plan": "Oracle baseline: Establish upper bound with perfect retrieval (20 samples)",
          "code": "#!/usr/bin/env python3\n\"\"\"\nExperiment Node 1: Oracle Baseline\nTests upper bound performance with perfect retrieval\n\"\"\"\nimport subprocess\nimport sys\n\ndef run():\n    \"\"\"Run Oracle experiment on 20 validation samples\"\"\"\n    cmd = [\n        sys.executable, \"code/main.py\",\n        \"--memory\", \"oracle\",\n        \"--samples\", \"20\",\n        \"--output\", \"results/node_1_oracle_baseline\"\n    ]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    print(result.stdout)\n    if result.stderr:\n        print(result.stderr, file=sys.stderr)\n\n    return result.returncode\n\nif __name__ == \"__main__\":\n    sys.exit(run())\n",
          "term_out": "",
          "analysis": "Oracle baseline achieved 80% accuracy, establishing upper bound. Even with perfect retrieval, agent makes errors (over-elaboration, missing details). 4 failures suggest judge is strict or task ceiling is 80%. Key insight: Perfect retrieval \u2260 perfect answers.",
          "metric": {
            "value": 0.8,
            "name": "accuracy",
            "maximize": true,
            "cost_usd": 0.17,
            "avg_time_seconds": 1.9
          },
          "is_buggy": false,
          "plots": [],
          "commit_hash": "9e54bcc"
        },
        "node-0a5b6b5d": {
          "id": "node-0a5b6b5d",
          "parent_id": "node-66c5275a",
          "children": [
            "node-056a9c0c"
          ],
          "step": 2,
          "stage": 3,
          "plan": "Filesystem: Direct file access with list/read/search tools (20 samples)",
          "code": "#!/usr/bin/env python3\n\"\"\"\nExperiment Node 2: Filesystem Access\nTests H2: Simple filesystem access outperforms specialized memory tools\n\"\"\"\nimport subprocess\nimport sys\n\ndef run():\n    \"\"\"Run Filesystem experiment on 20 validation samples\"\"\"\n    cmd = [\n        sys.executable, \"code/main.py\",\n        \"--memory\", \"filesystem\",\n        \"--samples\", \"20\",\n        \"--output\", \"results/node_2_filesystem\"\n    ]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    print(result.stdout)\n    if result.stderr:\n        print(result.stderr, file=sys.stderr)\n\n    return result.returncode\n\nif __name__ == \"__main__\":\n    sys.exit(run())\n",
          "term_out": "",
          "analysis": "Filesystem severely underperformed: 25% vs Oracle 80%. Agent gave up on 15/20 questions. Higher cost (/bin/zsh.19 vs /bin/zsh.17) due to inefficient search. H2 REJECTED: Filesystem does NOT outperform specialized tools in this setting. Tools need semantic search, not just file listing.",
          "metric": {
            "value": 0.25,
            "name": "accuracy",
            "maximize": true,
            "cost_usd": 0.19,
            "avg_time_seconds": 2.6
          },
          "is_buggy": false,
          "plots": [],
          "commit_hash": "12378fd"
        },
        "node-ebf73f5f": {
          "id": "node-ebf73f5f",
          "parent_id": "node-66c5275a",
          "children": [
            "node-143b3f85"
          ],
          "step": 3,
          "stage": 3,
          "plan": "Built-in MCP: Keyword-based memory search (20 samples)",
          "code": "#!/usr/bin/env python3\n\"\"\"\nExperiment Node 3: Built-in MCP\nTests keyword-based memory search tool\n\"\"\"\nimport subprocess\nimport sys\n\ndef run():\n    \"\"\"Run Built-in MCP experiment on 20 validation samples\"\"\"\n    cmd = [\n        sys.executable, \"code/main.py\",\n        \"--memory\", \"builtin_mcp\",\n        \"--samples\", \"20\",\n        \"--output\", \"results/node_3_builtin_mcp\"\n    ]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    print(result.stdout)\n    if result.stderr:\n        print(result.stderr, file=sys.stderr)\n\n    return result.returncode\n\nif __name__ == \"__main__\":\n    sys.exit(run())\n",
          "term_out": "",
          "analysis": "Built-in MCP achieved 70% accuracy, much better than Filesystem (25%) but below Oracle (80%). Cost is 3x Oracle (/bin/zsh.50 vs /bin/zsh.17) due to retrieving top-k sessions. 10% gap from Oracle suggests retrieval quality matters. H2 REVISED: Memory tools > filesystem, but at higher cost.",
          "metric": {
            "value": 0.7,
            "name": "accuracy",
            "maximize": true,
            "cost_usd": 0.5,
            "avg_time_seconds": 2.6
          },
          "is_buggy": false,
          "plots": [],
          "commit_hash": "d754b6d"
        },
        "node-b839c49c": {
          "id": "node-b839c49c",
          "parent_id": "node-66c5275a",
          "children": [
            "node-381612b1"
          ],
          "step": 4,
          "stage": 3,
          "plan": "Oracle 50 samples: Validate upper bound pattern holds at scale",
          "code": "#!/usr/bin/env python3\n\"\"\"\nExperiment Node 4: Oracle Baseline (50 samples)\nScale up to validate 80% accuracy pattern holds\n\"\"\"\nimport subprocess\nimport sys\n\ndef run():\n    \"\"\"Run Oracle experiment on 50 validation samples\"\"\"\n    cmd = [\n        sys.executable, \"code/main.py\",\n        \"--memory\", \"oracle\",\n        \"--samples\", \"50\",\n        \"--output\", \"results/node_4_oracle_50\"\n    ]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    print(result.stdout)\n    if result.stderr:\n        print(result.stderr, file=sys.stderr)\n\n    return result.returncode\n\nif __name__ == \"__main__\":\n    sys.exit(run())\n",
          "term_out": "",
          "analysis": "Oracle scaled to 90% at 50 samples (vs 80% at 20). Upper bound confirmed. Only 5 failures out of 50. This establishes ceiling for agentic QA on LME+.",
          "metric": {
            "value": 0.9,
            "name": "accuracy",
            "maximize": true,
            "cost_usd": 0.43,
            "avg_time_seconds": 1.7
          },
          "is_buggy": false,
          "plots": [],
          "commit_hash": "fb54951"
        },
        "node-056a9c0c": {
          "id": "node-056a9c0c",
          "parent_id": "node-0a5b6b5d",
          "children": [],
          "step": 5,
          "stage": 3,
          "plan": "Filesystem 50 samples: Validate underperformance pattern",
          "code": "#!/usr/bin/env python3\n\"\"\"\nExperiment Node 5: Filesystem (50 samples)\nValidate that filesystem underperformance holds at scale\n\"\"\"\nimport subprocess\nimport sys\n\ndef run():\n    \"\"\"Run Filesystem experiment on 50 validation samples\"\"\"\n    cmd = [\n        sys.executable, \"code/main.py\",\n        \"--memory\", \"filesystem\",\n        \"--samples\", \"50\",\n        \"--output\", \"results/node_5_filesystem_50\"\n    ]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    print(result.stdout)\n    if result.stderr:\n        print(result.stderr, file=sys.stderr)\n\n    return result.returncode\n\nif __name__ == \"__main__\":\n    sys.exit(run())\n",
          "term_out": "",
          "analysis": "Filesystem scaled to 32% at 50 samples (vs 25% at 20). Underperformance confirmed at scale. Agent gives up on most questions without semantic search.",
          "metric": {
            "value": 0.32,
            "name": "accuracy",
            "maximize": true,
            "cost_usd": 0.35,
            "avg_time_seconds": 2.3
          },
          "is_buggy": false,
          "plots": [],
          "commit_hash": "0a26ce5"
        },
        "node-143b3f85": {
          "id": "node-143b3f85",
          "parent_id": "node-ebf73f5f",
          "children": [],
          "step": 6,
          "stage": 3,
          "plan": "Built-in MCP 50 samples: Validate 70% accuracy pattern",
          "code": "#!/usr/bin/env python3\n\"\"\"\nExperiment Node 6: Built-in MCP (50 samples)\nValidate that MCP 70% pattern holds at scale\n\"\"\"\nimport subprocess\nimport sys\n\ndef run():\n    \"\"\"Run Built-in MCP experiment on 50 validation samples\"\"\"\n    cmd = [\n        sys.executable, \"code/main.py\",\n        \"--memory\", \"builtin_mcp\",\n        \"--samples\", \"50\",\n        \"--output\", \"results/node_6_builtin_mcp_50\"\n    ]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    print(result.stdout)\n    if result.stderr:\n        print(result.stderr, file=sys.stderr)\n\n    return result.returncode\n\nif __name__ == \"__main__\":\n    sys.exit(run())\n",
          "term_out": "",
          "analysis": "Built-in MCP scaled to 62% at 50 samples (vs 70% at 20). Performance drop suggests 20-sample batch was easier. Cost .62 (3.8x Oracle). Gap from Oracle (90% vs 62% = 28%) demonstrates critical importance of retrieval quality.",
          "metric": {
            "value": 0.62,
            "name": "accuracy",
            "maximize": true,
            "cost_usd": 1.62,
            "avg_time_seconds": 3.1
          },
          "is_buggy": false,
          "plots": [],
          "commit_hash": "94e43ec"
        },
        "node-381612b1": {
          "id": "node-381612b1",
          "parent_id": "node-b839c49c",
          "children": [],
          "step": 7,
          "stage": 3,
          "plan": "Oracle 50 fixed: Validate bug fix impact",
          "code": "#!/usr/bin/env python3\n\"\"\"\nExperiment Node 7: Oracle 50 (Fixed)\nRerun with bug fixes to validate results\n\"\"\"\nimport subprocess\nimport sys\n\ndef run():\n    \"\"\"Run Oracle experiment with fixed formatting\"\"\"\n    cmd = [\n        sys.executable, \"code/main.py\",\n        \"--memory\", \"oracle\",\n        \"--samples\", \"50\",\n        \"--output\", \"results/node_7_oracle_50_fixed\"\n    ]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    print(result.stdout)\n    if result.stderr:\n        print(result.stderr, file=sys.stderr)\n\n    return result.returncode\n\nif __name__ == \"__main__\":\n    sys.exit(run())\n",
          "term_out": "",
          "analysis": "Fixed version: 90% accuracy (same as buggy). Newline bug had zero impact on Oracle. 48/50 questions consistent with buggy run.",
          "metric": {
            "value": 0.9,
            "name": "accuracy",
            "maximize": true,
            "cost_usd": 0.44
          },
          "is_buggy": false,
          "plots": [],
          "commit_hash": "63a48e9"
        }
      },
      "root_ids": [
        "node-66c5275a"
      ],
      "created_at": "2026-01-22T15:09:52.338733",
      "completed_at": "2026-01-22T16:37:44.993409",
      "outcome": "success"
    },
    "stage_0_iter_1": {
      "stage": 0,
      "iteration": 1,
      "nodes": {},
      "root_ids": [],
      "created_at": "2026-01-22T14:41:49.303285",
      "completed_at": "2026-01-22T14:41:53.124067",
      "outcome": "success"
    }
  },
  "layouts": {
    "stage_2_iter_1": {},
    "stage_1_iter_1": {},
    "stage_4_iter_1": {},
    "stage_3_iter_1": {
      "node-66c5275a": {
        "x": 520.0,
        "y": 50
      },
      "node-0a5b6b5d": {
        "x": 140.0,
        "y": 200
      },
      "node-056a9c0c": {
        "x": 140.0,
        "y": 350
      },
      "node-ebf73f5f": {
        "x": 520.0,
        "y": 200
      },
      "node-143b3f85": {
        "x": 520.0,
        "y": 350
      },
      "node-b839c49c": {
        "x": 900.0,
        "y": 200
      },
      "node-381612b1": {
        "x": 900.0,
        "y": 350
      }
    },
    "stage_0_iter_1": {}
  }
};

// Global state
let currentStage = null;
let currentIteration = 1;
let selectedNode = null;
let canvas;
let panX = 0;
let panY = 0;
let zoom = 1;
let isDragging = false;
let lastMouseX = 0;
let lastMouseY = 0;

// Node dimensions
const NODE_WIDTH = 160;
const NODE_HEIGHT = 80;
const NODE_RADIUS = 8;

// Colors
const COLORS = {
    success: '#4ecca3',
    buggy: '#e94560',
    pending: '#888888',
    selected: '#ffc107',
    edge: '#0f3460',
    text: '#ffffff',
    subtext: '#888888'
};

function setup() {
    const container = document.getElementById('canvas-container');
    const w = container.clientWidth;
    const h = container.clientHeight;
    canvas = createCanvas(w, h);
    canvas.parent('canvas-container');

    // Initialize UI
    initializeStageNav();
    updateHypothesisDisplay();

    // Find the first stage with data
    findInitialStage();

    // Handle window resize
    window.addEventListener('resize', () => {
        const container = document.getElementById('canvas-container');
        resizeCanvas(container.clientWidth, container.clientHeight);
    });
}

function initializeStageNav() {
    const buttons = document.querySelectorAll('.stage-btn');
    buttons.forEach(btn => {
        const stage = parseInt(btn.dataset.stage);

        // Check stage status from history
        const history = TREE_DATA.stage_history || [];
        const stageEntries = history.filter(e => e.stage === stage);

        if (stageEntries.length > 0) {
            const latestEntry = stageEntries[stageEntries.length - 1];
            if (latestEntry.outcome === 'success') {
                btn.classList.add('completed');
            } else if (latestEntry.outcome === 'loop_back') {
                btn.classList.add('loop-back');
            }
        }

        btn.addEventListener('click', () => {
            selectStage(stage);
        });
    });
}

function findInitialStage() {
    const history = TREE_DATA.stage_history || [];
    if (history.length > 0) {
        const latest = history[history.length - 1];
        selectStage(latest.stage, latest.iteration);
    } else {
        // No history, check for any trees
        const treeKeys = Object.keys(TREE_DATA.trees || {});
        if (treeKeys.length > 0) {
            const match = treeKeys[0].match(/stage_(\d+)_iter_(\d+)/);
            if (match) {
                selectStage(parseInt(match[1]), parseInt(match[2]));
            }
        }
    }
}

function selectStage(stage, iteration = null) {
    currentStage = stage;

    // Find the latest iteration for this stage if not specified
    if (iteration === null) {
        const history = TREE_DATA.stage_history || [];
        const stageEntries = history.filter(e => e.stage === stage);
        if (stageEntries.length > 0) {
            currentIteration = stageEntries[stageEntries.length - 1].iteration;
        } else {
            currentIteration = 1;
        }
    } else {
        currentIteration = iteration;
    }

    // Update nav buttons
    document.querySelectorAll('.stage-btn').forEach(btn => {
        btn.classList.remove('active');
        if (parseInt(btn.dataset.stage) === stage) {
            btn.classList.add('active');
        }
    });

    // Reset view
    panX = 50;
    panY = 50;
    zoom = 1;
    selectedNode = null;
    updateNodeDetails(null);
}

function updateHypothesisDisplay() {
    const display = document.getElementById('hypothesis-display');
    if (TREE_DATA.hypothesis) {
        display.textContent = `Hypothesis: ${TREE_DATA.hypothesis}`;
    } else {
        display.textContent = 'No hypothesis set';
    }
}

function getCurrentTreeKey() {
    return `stage_${currentStage}_iter_${currentIteration}`;
}

function getCurrentTree() {
    const key = getCurrentTreeKey();
    return TREE_DATA.trees ? TREE_DATA.trees[key] : null;
}

function getCurrentLayout() {
    const key = getCurrentTreeKey();
    return TREE_DATA.layouts ? TREE_DATA.layouts[key] : null;
}

function draw() {
    background(26, 26, 46);

    if (currentStage === null) {
        drawEmptyState();
        return;
    }

    const tree = getCurrentTree();
    const layout = getCurrentLayout();

    if (!tree || !layout || Object.keys(tree.nodes || {}).length === 0) {
        drawEmptyState();
        return;
    }

    push();
    translate(panX, panY);
    scale(zoom);

    // Draw edges first
    drawEdges(tree, layout);

    // Draw nodes
    drawNodes(tree, layout);

    pop();
}

function drawEmptyState() {
    fill(100);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(16);
    text('No experiments in this stage yet', width / 2, height / 2 - 20);
    textSize(12);
    fill(80);
    text('Start by adding a root node to begin experimentation', width / 2, height / 2 + 10);
}

function drawEdges(tree, layout) {
    stroke(COLORS.edge);
    strokeWeight(2);

    for (const [nodeId, node] of Object.entries(tree.nodes || {})) {
        const pos = layout[nodeId];
        if (!pos) continue;

        for (const childId of node.children || []) {
            const childPos = layout[childId];
            if (childPos) {
                line(pos.x, pos.y + NODE_HEIGHT / 2, childPos.x, childPos.y - NODE_HEIGHT / 2);
            }
        }
    }
}

function drawNodes(tree, layout) {
    for (const [nodeId, node] of Object.entries(tree.nodes || {})) {
        const pos = layout[nodeId];
        if (!pos) continue;

        const x = pos.x - NODE_WIDTH / 2;
        const y = pos.y - NODE_HEIGHT / 2;

        // Determine node color
        let nodeColor;
        if (node.is_buggy) {
            nodeColor = color(COLORS.buggy);
        } else if (node.metric) {
            nodeColor = color(COLORS.success);
        } else {
            nodeColor = color(COLORS.pending);
        }

        // Draw selection highlight
        if (selectedNode === nodeId) {
            stroke(COLORS.selected);
            strokeWeight(3);
        } else {
            stroke(nodeColor);
            strokeWeight(1);
        }

        // Draw node rectangle
        fill(32, 32, 64);
        rect(x, y, NODE_WIDTH, NODE_HEIGHT, NODE_RADIUS);

        // Draw status indicator
        noStroke();
        fill(nodeColor);
        ellipse(x + 15, y + 15, 10, 10);

        // Draw step number
        fill(COLORS.text);
        textAlign(LEFT, TOP);
        textSize(10);
        text(`Step ${node.step}`, x + 25, y + 10);

        // Draw plan (truncated)
        fill(COLORS.subtext);
        textSize(11);
        const planText = node.plan || 'No plan';
        const truncated = planText.length > 40 ? planText.substring(0, 40) + '...' : planText;
        text(truncated, x + 10, y + 30, NODE_WIDTH - 20, NODE_HEIGHT - 40);

        // Draw metric if present
        if (node.metric && node.metric.value !== undefined) {
            fill(COLORS.success);
            textSize(12);
            textAlign(RIGHT, BOTTOM);
            text(node.metric.value.toFixed(3), x + NODE_WIDTH - 10, y + NODE_HEIGHT - 8);
        }
    }
}

function mousePressed() {
    if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;

    const tree = getCurrentTree();
    const layout = getCurrentLayout();
    if (!tree || !layout) return;

    // Check if clicked on a node
    const clickX = (mouseX - panX) / zoom;
    const clickY = (mouseY - panY) / zoom;

    for (const [nodeId, pos] of Object.entries(layout)) {
        const x = pos.x - NODE_WIDTH / 2;
        const y = pos.y - NODE_HEIGHT / 2;

        if (clickX >= x && clickX <= x + NODE_WIDTH &&
            clickY >= y && clickY <= y + NODE_HEIGHT) {
            selectedNode = nodeId;
            updateNodeDetails(tree.nodes[nodeId]);
            return;
        }
    }

    // Start panning
    isDragging = true;
    lastMouseX = mouseX;
    lastMouseY = mouseY;
}

function mouseReleased() {
    isDragging = false;
}

function mouseDragged() {
    if (isDragging) {
        panX += mouseX - lastMouseX;
        panY += mouseY - lastMouseY;
        lastMouseX = mouseX;
        lastMouseY = mouseY;
    }
}

function mouseWheel(event) {
    const zoomSensitivity = 0.001;
    zoom -= event.delta * zoomSensitivity;
    zoom = constrain(zoom, 0.3, 2);
    return false;
}

function updateNodeDetails(node) {
    const panel = document.getElementById('node-details');

    if (!node) {
        panel.innerHTML = `
            <div class="empty-state">
                <h3>No Node Selected</h3>
                <p>Click a node to view details</p>
            </div>
        `;
        return;
    }

    const metricHtml = node.metric
        ? `<span class="metric">${node.metric.name || 'value'}: ${node.metric.value.toFixed(4)}</span>`
        : '<span class="metric buggy">No metric</span>';

    const statusHtml = node.is_buggy
        ? '<span class="metric buggy">BUGGY</span>'
        : metricHtml;

    panel.innerHTML = `
        <div class="section">
            <div class="label">Node ID</div>
            <div class="value">${node.id}</div>
        </div>

        <div class="section">
            <div class="label">Step / Stage</div>
            <div class="value">Step ${node.step} | Stage ${node.stage}</div>
        </div>

        <div class="section">
            <div class="label">Status</div>
            <div class="value">${statusHtml}</div>
        </div>

        <div class="section">
            <div class="label">Plan</div>
            <div class="value">${escapeHtml(node.plan || 'No plan')}</div>
        </div>

        <div class="section">
            <div class="label">Code</div>
            <div class="code">${escapeHtml(node.code || 'No code')}</div>
        </div>

        <div class="section">
            <div class="label">Output</div>
            <div class="code">${escapeHtml(node.term_out || 'No output')}</div>
        </div>

        <div class="section">
            <div class="label">Analysis</div>
            <div class="value">${escapeHtml(node.analysis || 'No analysis')}</div>
        </div>

        ${node.commit_hash ? `
        <div class="section">
            <div class="label">Git Commit</div>
            <div class="value">${node.commit_hash}</div>
        </div>
        ` : ''}

        ${node.plots && node.plots.length > 0 ? `
        <div class="section">
            <div class="label">Plots</div>
            <div class="value">${node.plots.join(', ')}</div>
        </div>
        ` : ''}
    `;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Auto-reload check (for development)
let lastModified = null;

async function checkForUpdates() {
    try {
        const response = await fetch(window.location.href, { method: 'HEAD' });
        const modified = response.headers.get('last-modified');
        if (lastModified && modified !== lastModified) {
            window.location.reload();
        }
        lastModified = modified;
    } catch (e) {
        // Ignore errors
    }
}

// Check for updates every 2 seconds
setInterval(checkForUpdates, 2000);

    </script>
</body>
</html>
