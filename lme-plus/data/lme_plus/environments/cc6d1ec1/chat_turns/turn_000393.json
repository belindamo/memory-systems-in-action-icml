{
  "turn_global_index": 393,
  "session_index": 39,
  "session_id": "sharegpt_qT4tK9d_0",
  "turn_in_session": 0,
  "date": "2023/05/21 (Sun) 16:43",
  "role": "user",
  "content": "Im gonna send you code in two seperate messages, could you break it down for me?\n//sampling period is 224.38 us\n#define Adresa\\_MCP4725 96 //DAC adress\n#define pin\\_ADC A15 //ADC input pin\n#define pin\\_BAT A13 //Battery voltage input pin\n#define WHITE 0xFFFF //color\n#define BLACK 0x0000 //color\n#define RED 0xF800 //color\n#define GREEN 0x07E0 //color\n#define DKBLUE 0x000D //color\n#define buton\\_sus 7\n#define buton\\_OK 6\n#define buton\\_jos 5\n#define senzor\\_pas 3\n#define SDC\\_CS 53 //SD card control pin\n#include \n#include \n#include \n#include \"Free\\_Fonts.h\"\n#include \n\nTFT\\_HX8357 tft = TFT\\_HX8357();\narduinoFFT FFT = arduinoFFT();\n\nFile fisier;\n\nconst word nivele\\_bat[3] = {384, 392, 401}; //battery voltage threshold levels: low - med1 - med2 (V\\_bat/5V\\*1023\\*0.4)\n\n//GPR global parameters\nconst double pas\\_deplasare\\_GPR = 0.24; //GPR horizontal step [m]\nconst double banda = 587000000; //GPR bandwidth [Hz]; 910 MHz - 323 MHz\nconst double amplitudine\\_maxima = 30000; //maximum FFT module value (for scaling)\nconst word nr\\_esant = 256; //sample no.\n\n//menus\nconst char \\*medii\\_propagare[] = {\"Air - 0.3 m/ns\", \"Ice - 0.16 m/ns\", \"Dry sand - 0.15 m/ns\", \"Dry soil (Granite) - 0.13 m/ns\", \"Limestone - 0.12 m/ns\", \"Asphalt - 0.11 m/ns\", \"Concrete - 0.1 m/ns\", \"Moist soil - 0.09 m/ns\", \"Wet soil (Silt) - 0.07 m/ns\", \"Saturated sand (Clay) - 0.06 m/ns\", \"Sweet water - 0.03 m/ns\", \"Salt water - 0.01 m/ns\"};\nconst double viteze[] = {300000000, 160000000, 150000000, 130000000, 120000000, 110000000, 100000000, 90000000, 70000000, 60000000, 30000000, 10000000};\nconst word adancimi[] = {16, 32, 64, 128}; //resolution multiples\nconst double pasi\\_adanc[] = {10, 5, 2.5, 1, 0.5, 0.25, 0.1, 0.05, 0.025, 0.01};\nconst word zecimale\\_pasi\\_adanc[] = {0, 0, 1 , 0, 1, 2, 1, 2, 3, 2};\nconst word distante[] = {12, 24, 48, 96};\n\n//graph constants\nconst word orig\\_x = 60, orig\\_y = 290, latime\\_grafic = 400, inaltime\\_grafic = 256; //graph origin coord. and dimensions [pixels]\n//variabile globale afisare grafic\ndouble max\\_dist, pas\\_dist, max\\_adanc, min\\_adanc, pas\\_adanc, rezolutie; // [m]\ndouble c; //[m/s]\nword nr\\_cel\\_rez\\_oriz, nr\\_cel\\_rez\\_vert, inaltime\\_cel\\_rez, latime\\_cel\\_rez, nr\\_zecimale\\_pasi\\_adanc, xpos, ypos, pas = 0;\n\n//antenna coupling correction (anechoic chamber acquisition)\n//const word corectie[nr\\_esant] = {497, 497, 477, 383, 251, 163, 125, 113, 146, 210, 305, 430, 550, 682, 801, 893, 947, 964, 922, 787, 654, 569, 521, 486, 455, 446, 451, 454, 439, 409, 377, 352, 337, 332, 323, 334, 342, 354, 371, 384, 397, 410, 420, 433, 449, 468, 496, 528, 560, 596, 637, 674, 705, 726, 733, 735, 735, 738, 749, 757, 760, 754, 731, 699, 657, 597, 520, 432, 342, 264, 213, 180, 164, 164, 173, 194, 222, 252, 288, 316, 350, 390, 425, 459, 491, 522, 548, 571, 590, 606, 624, 642, 660, 681, 694, 703, 706, 701, 692, 676, 651, 623, 590, 557, 528, 501, 477, 457, 443, 433, 429, 429, 431, 433, 439, 449, 462, 476, 492, 508, 525, 543, 566, 587, 604, 609, 603, 589, 570, 547, 519, 482, 434, 376, 326, 277, 233, 194, 159, 147, 167, 224, 306, 383, 449, 503, 545, 576, 601, 611, 615, 616, 617, 617, 616, 614, 613, 609, 602, 593, 584, 577, 571, 566, 559, 553, 545, 539, 533, 528, 524, 521, 518, 515, 510, 505, 500, 496, 493, 490, 485, 480, 477, 475, 474, 475, 476, 479, 484, 490, 496, 502, 508, 514, 522, 532, 538, 542, 541, 540, 538, 536, 536, 534, 531, 525, 520, 511, 503, 497, 491, 487, 483, 479, 473, 467, 468, 468, 466, 466, 466, 466, 467, 467, 470, 468, 467, 467, 466, 466, 465, 465, 467, 468, 467, 468, 467, 471, 473, 475, 477, 480, 482, 484, 486, 489, 491, 494, 495, 497, 497, 498, 498, 499, 498, 498};\n\n//global variables\nword i, amplitudine\\_scalata, culoare, esantioane[nr\\_esant];\ndouble real[nr\\_esant], imag[nr\\_esant], amplitudine\\_corectata\\_cu\\_dist;\nboolean cont, card;\n\n//------------------------------------------------------------------------\nvoid setup()\n{\n Wire.begin();\n Wire.setClock(400000);\n tft.begin();\n tft.fillScreen(BLACK);\n tft.setRotation(1);\n tft.setTextColor(TFT\\_WHITE, TFT\\_BLACK);\n tft.setTextDatum(TC\\_DATUM); // Centered\n tft.setFreeFont(FSB12);\n xpos = tft.width() / 2; // Middle screen\n ypos = (tft.height() / 2) - tft.fontHeight(GFXFF); // Middle screen\n\n pinMode(buton\\_sus, INPUT);\n pinMode(buton\\_OK, INPUT);\n pinMode(buton\\_jos, INPUT);\n pinMode(senzor\\_pas, INPUT);\n\n tft.drawString(\" Mirel Paun 2020\", xpos, ypos, GFXFF);\n delay(1000);\n tft.fillScreen(BLACK);\n\n if (!digitalRead(buton\\_OK))\n {\n card = false; //do nor store on SD Card\n while (!digitalRead(buton\\_OK)) ;\n }\n else\n {\n\n if (SD.begin(SDC\\_CS))\n {\n card = true;\n Serial.begin(115200);\n delay(1000);\n tft.drawString(\"Waiting for PC to connect ...\", xpos, ypos, GFXFF);\n tft.drawString(\"Press OK to continue ...\", xpos, ypos + tft.fontHeight(GFXFF), GFXFF);\n while ((Serial.available() <= 0) && (digitalRead(buton\\_OK))) //wait for PC or OK button\n {\n delay(100);\n }\n if (Serial.available() > 0)\n {\n if (Serial.read() == 'A')\n {\n fisier = SD.open(\"Date.dat\");\n if (fisier)\n //Send stored data\n {\n tft.fillScreen(BLACK);\n tft.drawString(\"Connected. Sending file!\", xpos, ypos, GFXFF);\n while (fisier.available())\n {\n Serial.write(fisier.read());\n }\n fisier.close();\n tft.fillScreen(BLACK);\n tft.drawString(\"Deleting file ...\", xpos, ypos, GFXFF);\n if (SD.remove(\"Date.dat\")) {\n tft.drawString(\"Deleted!\", xpos, ypos + tft.fontHeight(GFXFF), GFXFF);\n }\n else {\n tft.drawString(\"Error deleting file!\", xpos, ypos + tft.fontHeight(GFXFF), GFXFF);\n }\n while (1) {\n ; // Stop\n }\n }\n else\n {\n tft.fillScreen(BLACK);\n tft.drawString(\"Error! File missing!\", xpos, ypos, GFXFF);\n while (1) {\n ; // Stop\n }\n }\n }\n }\n }\n else\n {\n card = false; //no SD card\n tft.drawString(\"SD Card missing!!!\", xpos, ypos, GFXFF);\n delay(2000);\n }\n tft.fillScreen(BLACK);\n }\n\n //DAC at 0\n Wire.beginTransmission(Adresa\\_MCP4725);\n Wire.write( 0 ); //MSB\n Wire.write( 0 ); //LSB\n Wire.endTransmission();\n delay(10);\n\n //Velocities menu--------------------------------------------------------------\n while (!digitalRead(buton\\_OK)) ;\n ypos = 10;\n tft.setFreeFont(FSB12);\n tft.drawString(\"Select propagation speed c:\", xpos, ypos, GFXFF);\n ypos += tft.fontHeight(GFXFF);\n tft.setFreeFont(FSB9);\n for (i = 0; i < (sizeof(medii\\_propagare) / sizeof(medii\\_propagare[0])); i++)\n {\n tft.drawString(medii\\_propagare[i], xpos, ypos, GFXFF);\n ypos += tft.fontHeight(GFXFF);\n }\n i = 0;\n ypos = 34 + i \\* tft.fontHeight(GFXFF);\n tft.drawRect(90, ypos, 300, 22, RED); //Draw cursor\n cont = false;\n do {\n while (digitalRead(buton\\_sus) && digitalRead(buton\\_jos) && digitalRead(buton\\_OK)) {\n ; // wait\n }\n delay(10);\n if (!digitalRead(buton\\_jos))\n {\n if (i < (sizeof(medii\\_propagare) / sizeof(medii\\_propagare[0]) - 1)) {\n i++;\n }\n else {\n i = 0;\n }\n tft.drawRect(90, ypos, 300, 22, BLACK);\n ypos = 34 + i \\* tft.fontHeight(GFXFF);\n tft.drawRect(90, ypos, 300, 22, RED);\n delay(500);\n }\n else if (!digitalRead(buton\\_sus))\n {\n if (i > 0) {\n i--;\n }\n else {\n i = (sizeof(medii\\_propagare) / sizeof(medii\\_propagare[0]) - 1);\n }\n tft.drawRect(90, ypos, 300, 22, BLACK);\n ypos = 34 + i \\* tft.fontHeight(GFXFF);\n tft.drawRect(90, ypos, 300, 22, RED);\n delay(500);\n }\n else if (!digitalRead(buton\\_OK))\n {\n c = viteze[i];\n cont = true;\n }\n } while (!cont);\n rezolutie = c / (2.0 \\* banda); //depth resolution [m]\n min\\_adanc = -4 \\* rezolutie; //offset cables + antennas (aprox. 4 \\* rezolution)\n\n if (card)\n {\n //Verify file existance, if missing, create it and write speed index\n if (!SD.exists(\"Date.dat\")) {\n fisier = SD.open(\"Date.dat\", FILE\\_WRITE);\n fisier.write(highByte(i));\n fisier.write(lowByte(i));\n fisier.close();\n }\n }\n\n //Depth menu--------------------------------------------------------------\n i = 0;\n word ind\\_adanc\\_max = sizeof(adancimi) / sizeof(adancimi[0]) - 1;\n\n tft.fillScreen(BLACK);\n while (!digitalRead(buton\\_OK)) ;\n ypos = 10;\n tft.setFreeFont(FSB12);\n tft.drawString(\"Select maximum displayed depth:\", xpos, ypos, GFXFF);\n ypos += tft.fontHeight(GFXFF);\n tft.setFreeFont(FSB9);\n for (i = 0; i <= ind\\_adanc\\_max; i++)\n {\n double adancime\\_temp = adancimi[i] \\* rezolutie + min\\_adanc;\n double zecimale = adancime\\_temp - floor(adancime\\_temp);\n String sir;\n if (zecimale < (adancime\\_temp / 10)) sir = String(adancime\\_temp, 0) + \" m\";\n else sir = String(adancime\\_temp, 1) + \" m\";\n char text[6];\n sir.toCharArray(text, 6);\n tft.drawString(text, xpos, ypos, GFXFF);\n ypos += tft.fontHeight(GFXFF);\n }\n i = 0;\n ypos = 34 + i \\* tft.fontHeight(GFXFF);\n tft.drawRect(90, ypos, 300, 22, RED); //Draw cursor\n cont = false;\n delay(1000);\n do {\n while (digitalRead(buton\\_sus) && digitalRead(buton\\_jos) && digitalRead(buton\\_OK)) {\n ; // wait\n }\n delay(10);\n if (!digitalRead(buton\\_jos))\n {\n if (i < ind\\_adanc\\_max) {\n i++;\n }\n else {\n i = 0;\n }\n tft.drawRect(90, ypos, 300, 22, BLACK);\n ypos = 34 + i \\* tft.fontHeight(GFXFF);\n tft.drawRect(90, ypos, 300, 22, RED);\n delay(500);\n }\n else if (!digitalRead(buton\\_sus))\n {\n if (i > 0) {\n i--;\n }\n else {\n i = ind\\_adanc\\_max;\n }\n tft.drawRect(90, ypos, 300, 22, BLACK);\n ypos = 34 + i \\* tft.fontHeight(GFXFF);\n tft.drawRect(90, ypos, 300, 22, RED);\n delay(500);\n }\n else if (!digitalRead(buton\\_OK))\n {\n nr\\_cel\\_rez\\_vert = adancimi[i];\n max\\_adanc = nr\\_cel\\_rez\\_vert \\* rezolutie + min\\_adanc;\n double pas\\_adanc\\_temp = (max\\_adanc - min\\_adanc) / 4;\n i = 0;\n while ((abs(pas\\_adanc\\_temp - pasi\\_adanc[i]) > abs(pas\\_adanc\\_temp - pasi\\_adanc[i + 1])) && ((i + 1) < (sizeof(pasi\\_adanc) / sizeof(pasi\\_adanc[0]) - 1)))\n {\n i++;\n }\n if (abs(pas\\_adanc\\_temp - pasi\\_adanc[i]) > abs(pas\\_adanc\\_temp - pasi\\_adanc[i + 1])) i++;\n pas\\_adanc = pasi\\_adanc[i];\n nr\\_zecimale\\_pasi\\_adanc = zecimale\\_pasi\\_adanc[i];\n cont = true;\n }\n } while (!cont);\n\n //Distance menu--------------------------------------------------------------\n tft.fillScreen(BLACK);\n while (!digitalRead(buton\\_OK)) ;\n ypos = 10;\n tft.setFreeFont(FSB12);\n tft.drawString(\"Select horizontal distance on screen:\", xpos, ypos, GFXFF);\n ypos += tft.fontHeight(GFXFF);\n tft.setFreeFont(FSB9);\n for (i = 0; i < (sizeof(distante) / sizeof(distante[0])); i++)\n {\n String sir = String(distante[i]) + \" m\";\n char text[5];\n sir.toCharArray(text, 5);\n tft.drawString(text, xpos, ypos, GFXFF);\n ypos += tft.fontHeight(GFXFF);\n }\n i = 0;\n ypos = 34 + i \\* tft.fontHeight(GFXFF);\n tft.drawRect(90, ypos, 300, 22, RED); //Draw cursor\n cont = false;\n delay(1000);\n do {\n while (digitalRead(buton\\_sus) && digitalRead(buton\\_jos) && digitalRead(buton\\_OK)) {\n ; // wait\n }\n delay(10);\n if (!digitalRead(buton\\_jos))\n {\n if (i < (sizeof(distante) / sizeof(distante[0]) - 1)) {\n i++;\n }\n else {\n i = 0;\n }\n tft.drawRect(90, ypos, 300, 22, BLACK);\n ypos = 34 + i \\* tft.fontHeight(GFXFF);\n tft.drawRect(90, ypos, 300, 22, RED);\n delay(500);\n }\n else if (!digitalRead(buton\\_sus))\n {\n if (i > 0) {\n i--;\n }\n else {\n i = (sizeof(distante) / sizeof(distante[0]) - 1);\n }\n tft.drawRect(90, ypos, 300, 22, BLACK);\n ypos = 34 + i \\* tft.fontHeight(GFXFF);\n tft.drawRect(90, ypos, 300, 22, RED);\n delay(500);\n }\n else if (!digitalRead(buton\\_OK))\n {\n max\\_dist = distante[i];\n pas\\_dist = max\\_dist / 6;\n cont = true;\n }\n } while (!cont);\n\n //graph parameters\n inaltime\\_cel\\_rez = inaltime\\_grafic / nr\\_cel\\_rez\\_vert; //[pixels]\n nr\\_cel\\_rez\\_oriz = max\\_dist / pas\\_deplasare\\_GPR;\n latime\\_cel\\_rez = latime\\_grafic / nr\\_cel\\_rez\\_oriz; //[pixels]\n // Draw grid\n tft.fillScreen(BLACK);\n Graph(tft, orig\\_x, orig\\_y, latime\\_grafic, inaltime\\_grafic, 0, max\\_dist, pas\\_dist, min\\_adanc, max\\_adanc, pas\\_adanc, \"GPR\", \"Distance [m]\", \"Depth [m]\");\n afis\\_card();\n masurare\\_afis\\_bat();\n}",
  "has_answer": false
}