{
  "session_id": "sharegpt_kS6twK0_14",
  "session_index": 15,
  "date": "2023/05/30 (Tue) 07:50",
  "turns": [
    {
      "role": "user",
      "content": "Route Handlers\nRoute Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.\n\nAn example route handler in the app directory\nGood to know: Route Handlers are only available inside the app directory. They are the equivalent of API Routes inside the pages directory meaning you do not need to use API Routes and Route Handlers together.\n\nConvention\nRoute Handlers are defined in a route.js|ts file inside the app directory:\n\napp/api/route.ts\nexport async function GET(request: Request) {}\nRoute Handlers can be nested inside the app directory, similar to page.js and layout.js. But there cannot be a route.js file at the same route segment level as page.js.\n\nSupported HTTP Methods\nThe following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS.\n\nExtended NextRequest and NextResponse APIs\nIn addition to supporting native Request and Response. Next.js extends them with NextRequest and NextResponse to provide convenient helpers for advanced use cases.\n\nBehavior\nStatic Route Handlers\nRoute Handlers are statically evaluated by default when using the GET method with the Response object.\n\napp/items/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function GET() {\n const res = await fetch('https://data.mongodb-api.com/...', {\n headers: {\n 'Content-Type': 'application/json',\n 'API-Key': process.env.DATA\\_API\\_KEY,\n },\n });\n const data = await res.json();\n\n return NextResponse.json({ data })\n}\nTypeScript Warning: Although Response.json() is valid, native TypeScript types currently shows an error, you can use NextResponse.json() for typed responses instead.\n\nStatic fetching can be beneficial to generate custom route handlers for robots.txt, rss.xml, sitemap.xml, and other routes. See Example.\n\nDynamic Route Handlers\nRoute handlers are evaluated dynamically when:\n\nUsing the Request object with the GET method.\nUsing any of the other HTTP methods.\nUsing Dynamic Functions like cookies and headers.\nFor example:\n\napp/products/api/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function GET(request: Request) {\n const { searchParams } = new URL(request.url);\n const id = searchParams.get('id');\n const res = await fetch(`https://data.mongodb-api.com/product/${id}`, {\n headers: {\n 'Content-Type': 'application/json',\n 'API-Key': process.env.DATA\\_API\\_KEY,\n },\n });\n const product = await res.json();\n\n return NextResponse.json({ product })\n}\nSimilarly, the POST method will cause the Route Handler to be evaluated dynamically.\n\napp/items/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function POST() {\n const res = await fetch('https://data.mongodb-api.com/...', {\n method: 'POST',\n headers: {\n 'Content-Type': 'application/json',\n 'API-Key': process.env.DATA\\_API\\_KEY,\n },\n body: JSON.stringify({ time: new Date().toISOString() }),\n });\n\n const data = await res.json();\n\n return NextResponse.json(data);\n}\n\nNote: Previously, API Routes could have been used for use cases like handling form submissions. Route Handlers are likely not the solution for these uses cases. We will be recommending the use of mutations for this when ready.\n\nRoute Resolution\nYou can consider a route the lowest level routing primitive.\n\nThey do not participate in layouts or client-side navigations like page.\nThere cannot be a route.js file at the same route as page.js.\nPage Route Result\napp/page.js app/route.js \u274c Conflict\napp/page.js app/api/route.js \u2705 Valid\napp/[user]/page.js app/api/route.js \u2705 Valid\nEach route.js or page.js file takes over all HTTP verbs for that route.\n\n// `app/page.js`\nexport default function Page() {\n return Hello, Next.js!\n===============\n\n;\n}\n\n// \u274c Conflict\n// `app/route.js`\nexport async function POST(request) {}\nExamples\nThe following examples show how to combine Route Handlers with other Next.js APIs and features.\n\nRevalidating Static Data\nYou can revalidate static data fetches using the next.revalidate option:\n\napp/items/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function GET() {\n const res = await fetch('https://data.mongodb-api.com/...', {\n next: { revalidate: 60 } // Revalidate every 60 seconds\n });\n const data = await res.json();\n\n return NextResponse.json(data)\n}\nAlternatively, you can the revalidate segment config option:\n\nexport const revalidate = 60;\nDynamic Functions\nRoute Handlers can be used with dynamic functions from Next.js, like cookies and headers.\n\nCookies\nYou can read cookies with cookies from next/headers. This server function can be called directly in a Route Handler, or nested inside of another function.\n\nThis cookies instance is read-only. To set cookies, you need to return a new Response using the Set-Cookie header.\n\napp/api/route.ts\nimport { cookies } from 'next/headers'\n\nexport async function GET(request: Request) {\n const cookieStore = cookies();\n const token = cookieStore.get('token');\n\n return new Response('Hello, Next.js!', {\n status: 200,\n headers: { 'Set-Cookie': `token=${token}` }\n });\n}\nAlternatively, you can use abstractions on top of the underlying Web APIs to read cookies (NextRequest):\n\napp/api/route.ts\nimport { type NextRequest } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n const token = request.cookies.get('token')\n}\nHeaders\nYou can read headers with headers from next/headers. This server function can be called directly in a Route Handler, or nested inside of another function.\n\nThis headers instance is read-only. To set headers, you need to return a new Response with new headers.\n\napp/api/route.ts\nimport { headers } from 'next/headers';\n\nexport async function GET(request: Request) {\n const headersList = headers();\n const referer = headersList.get('referer');\n\n return new Response('Hello, Next.js!', {\n status: 200,\n headers: { 'referer': referer }\n });\n}\nAlternatively, you can use abstractions on top of the underlying Web APIs to read headers (NextRequest):\n\napp/api/route.ts\nimport { type NextRequest } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n const requestHeaders = new Headers(request.headers)\n}\nRedirects\napp/api/route.ts\nimport { redirect } from 'next/navigation';\n\nexport async function GET(request: Request) {\n redirect('https://nextjs.org/')\n}\nDynamic Route Segments\nWe recommend reading the Defining Routes page before continuing.\n\nRoute Handlers can use Dynamic Segments to create request handlers from dynamic data.\n\napp/items/[slug]/route.js\nexport async function GET(request, { params }) {\n const slug = params.slug; // 'a', 'b', or 'c'\n}\nRoute Example URL params\napp/items/[slug]/route.js /items/a { slug: 'a' }\napp/items/[slug]/route.js /items/b { slug: 'b' }\napp/items/[slug]/route.js /items/c { slug: 'c' }\nNote: Using generateStaticParams() is not yet supported for use with Route Handlers.\n\nStreaming\napp/api/route.ts\n// https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream#convert\\_async\\_iterator\\_to\\_stream\nfunction iteratorToStream(iterator: any) {\n return new ReadableStream({\n async pull(controller) {\n const { value, done } = await iterator.next()\n\n if (done) {\n controller.close()\n } else {\n controller.enqueue(value)\n }\n },\n })\n}\n\nfunction sleep(time) {\n return new Promise((resolve) => {\n setTimeout(resolve, time)\n })\n}\n\nconst encoder = new TextEncoder()\n\nasync function\\* makeIterator() {\n yield encoder.encode('One\n\n')\n await sleep(200)\n yield encoder.encode('Two\n\n')\n await sleep(200)\n yield encoder.encode('Three\n\n')\n}\n\nexport async function GET() {\n const iterator = makeIterator()\n const stream = iteratorToStream(iterator)\n\n return new Response(stream)\n}\nRequest Body\nYou can read the Request body using the standard Web API methods:\n\napp/items/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function POST(request: Request) {\n const res = await request.json();\n return NextResponse.json({ res })\n}\nEdge and Node.js Runtimes\nRoute Handlers have an isomorphic Web API to support both Edge and Node.js runtimes seamlessly, including support for streaming. Since Route Handlers use the same route segment configuration as pages and layouts, they support long-awaited features like general-purpose statically regenerated Route Handlers.\n\nYou can use the runtime segment config option to specify the runtime:\n\nexport const runtime = 'experimental-edge';\nrobots.txt, rss.xml, and sitemap.xml\nYou can use Route Handlers to return non-UI content such as robots.txt, rss.xml, and sitemap.xml.\n\napp/robots.txt/route.ts\nexport async function GET() {\n return new Response(`User-agent: \\*\nAllow: /\n\nSitemap: https://www.example.com/sitemap.xml`);\n}\nSegment Config Options\nRoute Handlers use the same route segment configuration as pages and layouts.\n\napp/items/route.ts\nexport const dynamic = 'auto'\nexport const dynamicParams = true\nexport const revalidate = false\nexport const fetchCache = 'auto'\nexport const runtime = 'nodejs'\nexport const preferredRegion = 'auto'\nSee the API reference for more details.\n\nNext Steps\nroute.js\nAPI reference and examples for Route Handlers.\nNextRequest\nAPI reference for the extended Web Request API.\nNextResponse\nAPI reference for the extended Web Response API."
    },
    {
      "role": "assistant",
      "content": "Route Handlers Overview\n\nRoute Handlers allow you to create custom request handlers for a specific route using the Web Request and Response APIs. They are available only inside the app directory, and you should not use API Routes and Route Handlers together.\n\nTo define Route Handlers, create a route.js or route.ts file inside the app directory, like this:\n\napp/api/route.ts\n```javascript\nexport async function GET(request: Request) {}\n```\nSupported HTTP methods include GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. Next.js extends the native Request and Response with NextRequest and NextResponse to provide helpful utilities for advanced use cases.\n\nStatic Route Handlers are evaluated by default when using the GET method with the Response object, which can be beneficial for generating custom route handlers for robots.txt, rss.xml, sitemap.xml, and other routes.\n\nDynamic Route Handlers are evaluated when using the Request object with the GET method, using any of the other HTTP methods, or when using Dynamic Functions like cookies and headers.\n\nRoute Handlers can use Dynamic Segments to create request handlers from dynamic data, but using generateStaticParams() is not yet supported for use with Route Handlers.\n\nRoute Handlers support both Edge and Node.js runtimes seamlessly with an isomorphic Web API, and you can specify the runtime using the runtime segment config option.\n\nExamples of using Route Handlers include revalidating static data, reading cookies and headers, handling redirects, streaming responses, and returning non-UI content like robots.txt, rss.xml, and sitemap.xml.\n\nRoute Handlers use the same route segment configuration as pages and layouts, allowing for options like dynamic, dynamicParams, revalidate, fetchCache, runtime, and preferredRegion."
    }
  ]
}