{
  "turn_global_index": 124,
  "session_index": 11,
  "session_id": "sharegpt_NYFuCmY_0",
  "turn_in_session": 0,
  "date": "2023/03/01 (Wed) 11:16",
  "role": "user",
  "content": "This is part of a ros package and in the path rospy/src/rospy/topics.py\nclass Subscriber(Topic):\n \"\"\"\n Class for registering as a subscriber to a specified topic, where\n the messages are of a given type.\n \"\"\"\n def \\_\\_init\\_\\_(self, name, data\\_class, callback=None, callback\\_args=None,\n queue\\_size=None, buff\\_size=DEFAULT\\_BUFF\\_SIZE, tcp\\_nodelay=False):\n super(Subscriber, self).\\_\\_init\\_\\_(name, data\\_class, Registration.SUB)\n #add in args that factory cannot pass in\n\n # last person to set these to non-defaults wins, not much way\n # around this\n if queue\\_size is not None:\n self.impl.set\\_queue\\_size(queue\\_size)\n if buff\\_size != DEFAULT\\_BUFF\\_SIZE:\n self.impl.set\\_buff\\_size(buff\\_size)\n\n if callback is not None:\n # #1852\n # it's important that we call add\\_callback so that the\n # callback can be invoked with any latched messages\n self.impl.add\\_callback(callback, callback\\_args)\n # save arguments for unregister\n self.callback = callback\n self.callback\\_args = callback\\_args\n else:\n # initialize fields\n self.callback = self.callback\\_args = None \n if tcp\\_nodelay:\n self.impl.set\\_tcp\\_nodelay(tcp\\_nodelay) \n \nclass \\_SubscriberImpl(\\_TopicImpl):\n \"\"\"\n Underyling L{\\_TopicImpl} implementation for subscriptions.\n \"\"\"\n def \\_\\_init\\_\\_(self, name, data\\_class):\n \n super(\\_SubscriberImpl, self).\\_\\_init\\_\\_(name, data\\_class)\n # client-methods to invoke on new messages. should only modify\n # under lock. This is a list of 2-tuples (fn, args), where\n # args are additional arguments for the callback, or None\n self.callbacks = [] \n self.queue\\_size = None\n self.buff\\_size = DEFAULT\\_BUFF\\_SIZE\n self.tcp\\_nodelay = False\n\n def add\\_callback(self, cb, cb\\_args):\n if self.closed:\n raise ROSException(\"subscriber [%s] has been closed\"%(self.resolved\\_name))\n with self.c\\_lock:\n # we lock in order to serialize calls to add\\_callback, but\n # we copy self.callbacks so we can it\n new\\_callbacks = self.callbacks[:]\n new\\_callbacks.append((cb, cb\\_args))\n self.callbacks = new\\_callbacks\n\n # #1852: invoke callback with any latched messages\n for c in self.connections:\n if c.latch is not None:\n self.\\_invoke\\_callback(c.latch, cb, cb\\_args)\n\n def remove\\_callback(self, cb, cb\\_args):\n if self.closed:\n return\n with self.c\\_lock:\n # we lock in order to serialize calls to add\\_callback, but\n # we copy self.callbacks so we can it\n matches = [x for x in self.callbacks if x[0] == cb and x[1] == cb\\_args]\n if matches:\n new\\_callbacks = self.callbacks[:]\n # remove the first match\n new\\_callbacks.remove(matches[0])\n self.callbacks = new\\_callbacks\n if not matches:\n raise KeyError(\"no matching cb\")\n\n def \\_invoke\\_callback(self, msg, cb, cb\\_args):\n try:\n if cb\\_args is not None:\n cb(msg, cb\\_args)\n else:\n cb(msg)\n except Exception as e:\n if not is\\_shutdown():\n logerr(\"bad callback: %s\\n%s\"%(cb, traceback.format\\_exc()))\n else:\n \\_logger.warn(\"during shutdown, bad callback: %s\\n%s\"%(cb, traceback.format\\_exc()))\n \n def receive\\_callback(self, msgs):\n \"\"\"\n Called by underlying connection transport for each new message received\n @param msgs: message data\n @type msgs: [L{Message}]\n \"\"\"\n # save reference to avoid lock\n callbacks = self.callbacks\n for msg in msgs:\n for cb, cb\\_args in callbacks:\n self.\\_invoke\\_callback(msg, cb, cb\\_args)\n\n# Implementation note: Publisher attaches to a\n# \\_PublisherImpl singleton for that topic. The underlying impl\n# manages the connections for that publication and enables\n# thread-safe access\n\nclass Publisher(Topic):\n \"\"\"\n Class for registering as a publisher of a ROS topic.\n \"\"\"\n\n def \\_\\_init\\_\\_(self, name, data\\_class, subscriber\\_listener=None, tcp\\_nodelay=False, latch=False, headers=None):\n super(Publisher, self).\\_\\_init\\_\\_(name, data\\_class, Registration.PUB)\n\n if subscriber\\_listener:\n self.impl.add\\_subscriber\\_listener(subscriber\\_listener)\n if tcp\\_nodelay:\n get\\_tcpros\\_handler().set\\_tcp\\_nodelay(self.resolved\\_name, tcp\\_nodelay)\n if latch:\n self.impl.enable\\_latch()\n if headers:\n self.impl.add\\_headers(headers)\n \n def publish(self, \\*args, \\*\\*kwds):\n if self.impl is None:\n raise ROSException(\"publish() to an unregistered() handle\")\n if not is\\_initialized():\n raise ROSException(\"ROS node has not been initialized yet. Please call init\\_node() first\")\n data = args\\_kwds\\_to\\_message(self.data\\_class, args, kwds)\n try:\n self.impl.acquire()\n self.impl.publish(data)\n except roslib.message.SerializationError as e:\n # can't go to rospy.logerr(), b/c this could potentially recurse\n \\_logger.error(traceback.format\\_exc(e))\n raise ROSSerializationException(str(e))\n finally:\n self.impl.release() \n\nclass \\_PublisherImpl(\\_TopicImpl):\n \n def \\_\\_init\\_\\_(self, name, data\\_class):\n super(\\_PublisherImpl, self).\\_\\_init\\_\\_(name, data\\_class)\n if python3 == 0:\n self.buff = StringIO()\n else:\n self.buff = BytesIO()\n self.publock = threading.RLock() #for acquire()/release\n self.subscriber\\_listeners = []\n\n # additional client connection headers\n self.headers = {}\n \n # publish latch, starts disabled\n self.is\\_latch = False\n self.latch = None\n \n #STATS\n self.message\\_data\\_sent = 0\n def publish(self, message, connection\\_override=None):\n #TODO: should really just use IOError instead of rospy.ROSException\n\n if self.closed:\n # during shutdown, the topic can get closed, which creates\n # a race condition with user code testing is\\_shutdown\n if not is\\_shutdown():\n raise ROSException(\"publish() to a closed topic\")\n else:\n return\n \n if self.is\\_latch:\n self.latch = message\n\n if not self.has\\_connections():\n #publish() falls through\n return False\n\n if connection\\_override is None:\n #copy connections so we can iterate safely\n conns = self.connections\n else:\n conns = [connection\\_override]\n\n # #2128 test our buffer. I don't now how this got closed in\n # that case, but we can at least diagnose the problem.\n b = self.buff\n try:\n b.tell()\n\n # serialize the message\n self.seq += 1 #count messages published to the topic\n serialize\\_message(b, self.seq, message)\n\n # send the buffer to all connections\n err\\_con = []\n data = b.getvalue()\n\n for c in conns:\n try:\n if not is\\_shutdown():\n c.write\\_data(data)\n except TransportTerminated as e:\n logdebug(\"publisher connection to [%s] terminated, see errorlog for details:\\n%s\"%(c.endpoint\\_id, traceback.format\\_exc()))\n err\\_con.append(c)\n except Exception as e:\n # greater severity level\n logdebug(\"publisher connection to [%s] terminated, see errorlog for details:\\n%s\"%(c.endpoint\\_id, traceback.format\\_exc()))\n err\\_con.append(c)\n\n # reset the buffer and update stats\n self.message\\_data\\_sent += b.tell() #STATS\n b.seek(0)\n b.truncate(0)\n \n except ValueError:\n if self.closed:\n if is\\_shutdown():\n # we offer no guarantees on publishes that occur\n # during shutdown, so this is not exceptional.\n return\n else:\n # this indicates that user-level code most likely\n # closed the topic, which is exceptional.\n raise ROSException(\"topic was closed during publish()\")\n else:\n # unexpected, so re-raise original error\n raise\n\n # remove any bad connections\n for c in err\\_con:\n try:\n # connection will callback into remove\\_connection when\n # we close it\n c.close()\n except:\n pass\n\n#################################################################################\n# TOPIC MANAGER/LISTENER\n\nclass \\_TopicManager(object):\n\n def \\_\\_init\\_\\_(self):\n \"\"\"ctor.\"\"\"\n super(\\_TopicManager, self).\\_\\_init\\_\\_()\n self.pubs = {} #: { topic: \\_PublisherImpl }\n self.subs = {} #: { topic: \\_SubscriberImpl }\n self.topics = set() # [str] list of topic names\n self.lock = threading.Condition()\n self.closed = False\n \\_logger.info(\"topicmanager initialized\")\n\n def get\\_pub\\_sub\\_info(self):\n with self.lock:\n info = []\n for s in chain(iter(self.pubs.values()), iter(self.subs.values())):\n info.extend(s.get\\_stats\\_info())\n return info\n \n def get\\_pub\\_sub\\_stats(self):\n with self.lock:\n return [s.get\\_stats() for s in self.pubs.values()],\\\n [s.get\\_stats() for s in self.subs.values()]\n \n def close\\_all(self):\n self.closed = True\n with self.lock:\n for t in chain(iter(self.pubs.values()), iter(self.subs.values())):\n t.close()\n self.pubs.clear()\n self.subs.clear() \n \n def \\_add(self, ps, rmap, reg\\_type):\n resolved\\_name = ps.resolved\\_name\n \\_logger.debug(\"tm.\\_add: %s, %s, %s\", resolved\\_name, ps.type, reg\\_type)\n with self.lock:\n rmap[resolved\\_name] = ps\n self.topics.add(resolved\\_name)\n \n # NOTE: this call can take a lengthy amount of time (at\n # least until its reimplemented to use queues)\n get\\_registration\\_listeners().notify\\_added(resolved\\_name, ps.type, reg\\_type)\n\n def \\_recalculate\\_topics(self):\n \"\"\"recalculate self.topics. expensive\"\"\"\n self.topics = set([x.resolved\\_name for x in self.pubs.values()] +\n [x.resolved\\_name for x in self.subs.values()])\n \n def \\_remove(self, ps, rmap, reg\\_type):\n resolved\\_name = ps.resolved\\_name\n \\_logger.debug(\"tm.\\_remove: %s, %s, %s\", resolved\\_name, ps.type, reg\\_type)\n with self.lock:\n del rmap[resolved\\_name]\n self. \\_recalculate\\_topics()\n \n # NOTE: this call can take a lengthy amount of time (at\n # least until its reimplemented to use queues)\n get\\_registration\\_listeners().notify\\_removed(resolved\\_name, ps.type, reg\\_type)\n\n def get\\_impl(self, reg\\_type, resolved\\_name):\n \"\"\"\n Get the L{\\_TopicImpl} for the specified topic. This is mainly for\n testing purposes. Unlike acquire\\_impl, it does not alter the\n ref count.\n @param resolved\\_name: resolved topic name\n @type resolved\\_name: str\n @param reg\\_type: L{rospy.registration.Registration.PUB} or L{rospy.registration.Registration.SUB}\n @type reg\\_type: str\n \"\"\"\n if reg\\_type == Registration.PUB:\n rmap = self.pubs\n elif reg\\_type == Registration.SUB:\n rmap = self.subs\n else:\n raise TypeError(\"invalid reg\\_type: %s\"%s)\n return rmap.get(resolved\\_name, None)\n \n if reg\\_type == Registration.PUB:\n rmap = self.pubs\n impl\\_class = \\_PublisherImpl\n elif reg\\_type == Registration.SUB:\n rmap = self.subs\n impl\\_class = \\_SubscriberImpl\n else:\n raise TypeError(\"invalid reg\\_type: %s\"%s)\n with self.lock:\n impl = rmap.get(resolved\\_name, None) \n if not impl:\n impl = impl\\_class(resolved\\_name, data\\_class)\n self.\\_add(impl, rmap, reg\\_type)\n impl.ref\\_count += 1\n return impl\n\n def release\\_impl(self, reg\\_type, resolved\\_name):\n if reg\\_type == Registration.PUB:\n rmap = self.pubs\n else:\n rmap = self.subs\n with self.lock:\n # check for race condition where multiple things are cleaning up at once\n if self.closed:\n return\n impl = rmap.get(resolved\\_name, None)\n assert impl is not None, \"cannot release topic impl as impl [%s] does not exist\"%resolved\\_name\n impl.ref\\_count -= 1\n assert impl.ref\\_count >= 0, \"topic impl's reference count has gone below zero\"\n if impl.ref\\_count == 0:\n \\_logger.debug(\"topic impl's ref count is zero, deleting topic %s...\", resolved\\_name)\n impl.close()\n self.\\_remove(impl, rmap, reg\\_type)\n del impl\n \\_logger.debug(\"... done deleting topic %s\", resolved\\_name)\n\n def get\\_publisher\\_impl(self, resolved\\_name):\n return self.pubs.get(resolved\\_name, None)\n\n def get\\_subscriber\\_impl(self, resolved\\_name):\n return self.subs.get(resolved\\_name, None)\n\n def has\\_subscription(self, resolved\\_name): \n return resolved\\_name in self.subs\n\n def has\\_publication(self, resolved\\_name):\n return resolved\\_name in self.pubs\n\n def get\\_topics(self): \n return self.topics\n \n def \\_get\\_list(self, rmap):\n return [[k, v.type] for k, v in rmap.items()]\n\n ## @return [[str,str],]: list of topics subscribed to by this node, [ [topic1, topicType1]...[topicN, topicTypeN]]\n def get\\_subscriptions(self):\n return self.\\_get\\_list(self.subs)\n\n ## @return [[str,str],]: list of topics published by this node, [ [topic1, topicType1]...[topicN, topicTypeN]]\n def get\\_publications(self):\n return self.\\_get\\_list(self.pubs)\n\nset\\_topic\\_manager(\\_TopicManager())\n\nI want to make a new package that inherits this package but overwrites these two functions :\n\n\\_PublisherImpl.publish and \\_SubscriberImpl.\\_invoke\\_callback\n\nHow should i structure my ros package and what src files should I have and how should they look?",
  "has_answer": false
}