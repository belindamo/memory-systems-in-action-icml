{
  "turn_global_index": 117,
  "session_index": 11,
  "session_id": "sharegpt_Aeo2AOL_0",
  "turn_in_session": 1,
  "date": "2023/03/15 (Wed) 11:30",
  "role": "assistant",
  "content": "/\\*\\*\n\n* Generate a regex pattern from a character matrix and a set of distinct datums.\n* If the number of distinct datums is greater than the maximum allowed distinct datums,\n* a regex pattern is generated by analyzing each column of the character matrix and combining the results.\n* Otherwise, the regex pattern is generated by escaping each datum in the set and joining them with \"|\".\n* \n* @param charMatrix a two-dimensional array of long values representing characters\n* @param distinctDatums a set of distinct datums to generate a regex pattern from\n* @return a string representing the generated regex pattern\n\\*/\nprivate def generateRegex(charMatrix: Array[Array[Long]], distinctDatums: Set[String]): String = {\n// Check if the number of distinct datums exceeds the maximum allowed distinct datums\nif (distinctDatums.size > MAX\\_DISTINCT\\_SET) {\n// Get the sizes of each distinct datum\nval charSizes = distinctDatums.map(\\_.trim.length)\n// Get the maximum and minimum sizes of the distinct datums\nval maxElementSize = charSizes.max\nval minElementSize = charSizes.min\n\n// Create a list buffer to store the regex patterns for each column of the character matrix\nval regexBuilder = new ListBuffer[String]\n\n// Iterate through each character position in the matrix, up to a maximum number of characters to analyze\n(0 until MAX\\_CHARS\\_TO\\_ANALYZE).foreach {\ncharPos =>\n// Get an array of characters at the current position in the matrix\nval charArray = charMatrix.map(\\_(charPos))\n// Get a regex pattern for the valid characters in the array\nval regexToAdd = getValidChars(charArray) match {\ncase Some(\".\") => Some(\".\")\ncase Some(validChars) =>\n// Reduce the regex pattern for the valid characters\nval resultRegex = reduceRegex(validChars)\n// If the resulting regex pattern has only one character, use it as is\nif (resultRegex.replaceAllLiterally(\"\\\",\"\").length == 1) Some(resultRegex)\n// Otherwise, wrap the pattern in a character class\nelse Some(s\"[$resultRegex]\")\ncase \\_ => None\n}\n// Add the regex pattern to the list buffer, with optional \"?\" suffix for each character position\nregexToAdd match {\ncase Some(value) =>\nif (charPos >= minElementSize) {\nregexBuilder.append(s\"$value?\")\n} else {\nregexBuilder.append(value)\n}\ncase \\_ => ()\n}\n}\n\n// If the maximum size of a distinct datum is greater than the maximum number of characters to analyze, add a \".*\" suffix\nif (maxElementSize >= MAX\\_CHARS\\_TO\\_ANALYZE) {\nregexBuilder.append(\".*\")\n}\n\n// Combine consecutive regex patterns in the list buffer and wrap the resulting pattern with start and end markers\nval combinedTokens = combineConsecutiveTokens(regexBuilder).mkString\n\"^(?>\" + combinedTokens + \")$\"\n}\nelse {\n// Escape each datum in the set and join them with \"|\" to create a regex pattern\ndistinctDatums.map(escapeRegex).mkString(\"^(\", \"|\", \")$\")\n}\n}",
  "has_answer": false
}