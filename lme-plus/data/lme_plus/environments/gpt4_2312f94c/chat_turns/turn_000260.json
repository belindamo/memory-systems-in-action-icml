{
  "turn_global_index": 260,
  "session_index": 25,
  "session_id": "sharegpt_uVeeJj8_0",
  "turn_in_session": 3,
  "date": "2023/03/15 (Wed) 21:42",
  "role": "assistant",
  "content": "Yes, you can update the previous example to find restaurants at midpoints where a midpoint is considered equal driving time between two addresses. To achieve this, you can use the Google Maps Distance Matrix API to calculate the driving times between the two addresses and the potential restaurant locations.\n\nHere's an updated version of the previous implementation that considers equal driving time:\n\n1. First, install the required packages (if not done already):\n```bash\nnpm init -y\nnpm install express request googleapis yelp-fusion\n```\n1. Create an `index.js` file and implement the following code:\n```javascript\nconst express = require('express');\nconst request = require('request');\nconst { google } = require('googleapis');\nconst yelp = require('yelp-fusion');\n\nconst app = express();\nconst apiKey = 'YOUR_GOOGLE_MAPS_API_KEY';\nconst yelpApiKey = 'YOUR_YELP_API_KEY';\nconst yelpClient = yelp.client(yelpApiKey);\n\napp.use(express.json());\n\nasync function getGeoCoordinates(address) {\n  const maps = google.maps({ version: '3.44', apiKey });\n  const geocoder = new maps.Geocoder();\n\n  try {\n    const result = await geocoder.geocode({ address });\n    return result.results[0].geometry.location;\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nasync function getRestaurants(coord1, coord2) {\n  const midpoint = {\n    lat: (coord1.lat + coord2.lat) / 2,\n    lng: (coord1.lng + coord2.lng) / 2,\n  };\n\n  try {\n    const response = await yelpClient.search({\n      term: 'restaurant',\n      latitude: midpoint.lat,\n      longitude: midpoint.lng,\n      radius: 5000,\n      sort_by: 'best_match',\n    });\n\n    return response.jsonBody.businesses;\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nasync function filterByEqualDrivingTime(coord1, coord2, restaurants) {\n  const maps = google.maps({ version: '3.44', apiKey });\n  const distanceMatrix = new maps.DistanceMatrixService();\n\n  const destinations = restaurants.map((restaurant) => ({\n    lat: restaurant.coordinates.latitude,\n    lng: restaurant.coordinates.longitude,\n  }));\n\n  try {\n    const result = await distanceMatrix.getDistanceMatrix({\n      origins: [coord1, coord2],\n      destinations,\n      mode: 'driving',\n      units: 'metric',\n    });\n\n    const drivingTimes = result.rows.map((row) => row.elements.map((element) => element.duration.value));\n    const equalDrivingTimeRestaurants = [];\n\n    for (let i = 0; i < drivingTimes[0].length; i++) {\n      const timeDifference = Math.abs(drivingTimes[0][i] - drivingTimes[1][i]);\n\n      // You can adjust the tolerance in seconds as needed (e.g., 60 seconds)\n      if (timeDifference <= 60) {\n        equalDrivingTimeRestaurants.push(restaurants[i]);\n      }\n    }\n\n    return equalDrivingTimeRestaurants;\n  } catch (error) {\n    console.error(error);\n  }\n}\n\napp.post('/recommendations', async (req, res) => {\n  try {\n    const { address1, address2 } = req.body;\n\n    const coord1 = await getGeoCoordinates(address1);\n    const coord2 = await getGeoCoordinates(address2);\n\n    const allRestaurants = await getRestaurants(coord1, coord2);\n    const filteredRestaurants = await filterByEqualDrivingTime(coord1, coord2, allRestaurants);\n\n    res.json(filteredRestaurants);\n  } catch (error) {\n    console.error(error);\n```",
  "has_answer": false
}