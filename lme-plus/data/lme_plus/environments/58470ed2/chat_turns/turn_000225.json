{
  "turn_global_index": 225,
  "session_index": 23,
  "session_id": "sharegpt_Aeo2AOL_0",
  "turn_in_session": 3,
  "date": "2023/05/24 (Wed) 19:17",
  "role": "assistant",
  "content": "```scss\n/**\n  * Generate a regex pattern from a character matrix and a set of distinct datums.\n  * If the number of distinct datums is greater than the maximum allowed distinct datums,\n  * a regex pattern is generated by analyzing each column of the character matrix and combining the results.\n  * Otherwise, the regex pattern is generated by escaping each datum in the set and joining them with \"|\".\n  *\n  * @param charMatrix     a two-dimensional array of long values representing characters\n  * @param distinctDatums a set of distinct datums to generate a regex pattern from\n  * @return a string representing the generated regex pattern\n  */\nprivate def generateRegex(charMatrix: Array[Array[Long]], distinctDatums: Set[String]): String = {\n  // Check if the number of distinct datums exceeds the maximum allowed distinct datums\n  if (distinctDatums.size > MAX_DISTINCT_SET) {\n    // Get the sizes of each distinct datum\n    val charSizes = distinctDatums.map(_.trim.length)\n    // Get the maximum and minimum sizes of the distinct datums\n    val maxElementSize = charSizes.max\n    val minElementSize = charSizes.min\n\n    // Create a list buffer to store the regex patterns for each column of the character matrix\n    val regexBuilder = new ListBuffer[String]\n\n    // Iterate through each character position in the matrix, up to a maximum number of characters to analyze\n    (0 until MAX_CHARS_TO_ANALYZE).foreach {\n      charPos =>\n        // Get an array of characters at the current position in the matrix\n        val charArray = charMatrix.map(_(charPos))\n        // Get a regex pattern for the valid characters in the array\n        val regexToAdd = getValidChars(charArray) match {\n          case Some(\".\") => Some(\".\")\n          case Some(validChars) =>\n            // Reduce the regex pattern for the valid characters\n            val resultRegex = reduceRegex(validChars)\n            // If the resulting regex pattern has only one character, use it as is\n            if (resultRegex.replaceAllLiterally(\"\\\\\",\"\").length == 1) Some(resultRegex)\n            // Otherwise, wrap the pattern in a character class\n            else Some(s\"[$resultRegex]\")\n          case _ => None\n        }\n        // Add the regex pattern to the list buffer, with optional \"?\" suffix for each character position\n        regexToAdd match {\n          case Some(value) =>\n            if (charPos >= minElementSize) {\n              regexBuilder.append(s\"$value?\")\n            } else {\n              regexBuilder.append(value)\n            }\n          case _ => ()\n        }\n    }\n\n    // If the maximum size of a distinct datum is greater than the maximum number of characters to analyze, add a \".*\" suffix\n    if (maxElementSize >= MAX_CHARS_TO_ANALYZE) {\n      regexBuilder.append(\".*\")\n    }\n\n    // Combine consecutive regex patterns in the list buffer and wrap the resulting pattern with start and end markers\n    val combinedTokens = combineConsecutiveTokens(regexBuilder).mkString\n    \"^(?>\" + combinedTokens + \")$\"\n  }\n  else {\n    // Escape each datum in the set and join them with \"|\" to create a regex pattern\n    distinctDatums.map(escapeRegex).mkString(\"^(\", \"|\", \")$\")\n  }\n}\n```",
  "has_answer": false
}