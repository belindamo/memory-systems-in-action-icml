{
  "turn_global_index": 387,
  "session_index": 39,
  "session_id": "sharegpt_2wPZTqA_0",
  "turn_in_session": 1,
  "date": "2023/03/08 (Wed) 20:22",
  "role": "assistant",
  "content": "Here is an example SQL Server query that should accomplish what you're looking for:\n```\nWITH cte AS (\n    SELECT \n        t1.code, \n        t1.punchdatetime, \n        t2.calendardate, \n        t2.starttime, \n        t2.endtime\n    FROM \n        punches t1\n    JOIN \n        shifts t2 \n        ON t1.code = t2.code \n        AND t1.punchdatetime BETWEEN DATEADD(hour, -4, t2.starttime) AND DATEADD(hour, 4, t2.endtime)\n        OR (t2.starttime IS NULL AND t2.endtime IS NULL)\n)\n\nSELECT \n    code, \n    calendardate, \n    MIN(punchdatetime) as startdatetime, \n    MAX(punchdatetime) as enddatetime, \n    CASE \n        WHEN MIN(punchdatetime) = MAX(punchdatetime) THEN 'Punching'\n        ELSE 'PunchOut' \n    END as punching\nFROM \n    cte\nGROUP BY \n    code, \n    calendardate\n```\nThis query uses a common table expression (CTE) to join the two tables based on the code and the punchdatetime falling between the starttime and endtime shifted by 4 hours. It then groups the results by code and calendardate and selects the minimum and maximum punchdatetime as the start and end datetime, respectively. The last column is using a simple case statement to identify whether this is punching or punchout.\nPlease note that this is a sample and it might not work for your specific use case and you might need to tweak it a bit.",
  "has_answer": false
}