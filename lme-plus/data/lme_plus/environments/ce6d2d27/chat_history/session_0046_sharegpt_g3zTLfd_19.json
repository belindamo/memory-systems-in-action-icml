{
  "session_id": "sharegpt_g3zTLfd_19",
  "session_index": 46,
  "date": "2023/07/13 (Thu) 10:05",
  "turns": [
    {
      "role": "assistant",
      "content": "I see. In that case, let's update the `FigureCanvasTkAgg`'s `figure` property with the newly generated plot each time the `update_graph` function is called. Here's the updated `update_graph` function that does this:\n```python\ndef update_graph(*args, fig=fig):\n    fig.clf()\n    graph_type = graph_type_var.get()\n    if graph_type == \"pairplot\":\n        pair_grid = sns.pairplot(df, hue='Dataset', kind='reg')\n        canvas_widget.figure = pair_grid.fig\n    elif graph_type == \"histogram\":\n        ax = fig.add_subplot(111)\n        sns.histplot(data=df, x=\"Age\", hue=\"Dataset\", kde=True, ax=ax)\n        canvas_widget.figure = fig\n    elif graph_type == \"boxplot\":\n        ax = fig.add_subplot(111)\n        sns.boxplot(data=df, x=\"Dataset\", y=\"Total_Bilirubin\", ax=ax)\n        canvas_widget.figure = fig\n    canvas_widget.draw_idle()\n```\nNotice how we create a new `ax` object when generating a histogram or a boxplot and add it to the `fig`. Then, we set the `figure` property of the `FigureCanvasTkAgg` to the `fig` object for all three cases. Finally, we call the `draw_idle` method of the `FigureCanvasTkAgg` object to update the plot.\n\nLet me know if this works for you."
    },
    {
      "role": "user",
      "content": "no it dont work itried it already"
    },
    {
      "role": "assistant",
      "content": "In that case, you could try setting the size of the canvas and figure to be relative to the size of the window. Here's an updated `visualize` function that does this:\n```less\ndef visualize(window,graph_type_var,default):\n    # Create a canvas widget and add a scrollbar to it\n    canvas = tk.Canvas(window)\n    scrollbar = tk.Scrollbar(window, orient=\"vertical\", command=canvas.yview)\n    scrollable_frame = tk.Frame(canvas)\n\n    # Configure the canvas to scroll the scrollable_frame\n    canvas.configure(yscrollcommand=scrollbar.set)\n    canvas.pack(side=\"left\", fill=\"both\", expand=True)\n    scrollbar.pack(side=\"right\", fill=\"y\")\n\n    # Add the scrollable_frame to the canvas\n    canvas.create_window((0, 0), window=scrollable_frame, anchor=\"nw\")\n\n    # Create a FigureCanvasTkAgg inside the scrollable_frame\n    fig = plt.Figure()\n    width = window.winfo_width()\n    height = window.winfo_height()\n    fig.set_size_inches(width/100, height/100)\n    canvas_widget = FigureCanvasTkAgg(fig, master=scrollable_frame)\n    canvas_widget.draw()\n    canvas_widget.get_tk_widget().pack(side='top', fill='both', expand=True)\n\n    # Bind the canvas to the scrollable_frame\n    scrollable_frame.bind(\"<Configure>\", lambda e: canvas.configure(scrollregion=canvas.bbox(\"all\")))\n\n    # Define a callback function to update the graph when the dropdown value changes\n    def update_graph(*args,fig=fig):\n        fig.clf()\n        graph_type = graph_type_var.get()\n        if graph_type == \"pairplot\":\n            pair_grid = sns.pairplot(df, hue='Dataset', kind='reg', height=height/80, aspect=width/height)\n            pair_grid.fig.set_size_inches(width/100, height/100)\n            canvas_widget.figure=pair_grid.fig\n        elif graph_type == \"histogram\":\n            ax = fig.add_subplot(111)\n            sns.histplot(data=df, x=\"Age\", hue=\"Dataset\", kde=True, ax=ax)\n            ax.set_title('Age vs. Liver Disease', fontsize=14)\n            ax.set_xlabel('Age', fontsize=12)\n            ax.set_ylabel('Count', fontsize=12)\n            ax.legend(['No Liver Disease', 'Liver Disease'])\n        elif graph_type == \"boxplot\":\n            ax = fig.add_subplot(111)\n            sns.boxplot(data=df, x=\"Dataset\", y=\"Total_Bilirubin\", ax=ax)\n            ax.set_title('Liver Disease vs. Total Bilirubin', fontsize=14)\n            ax.set_xlabel('Liver Disease', fontsize=12)\n            ax.set_ylabel('Total Bilirubin', fontsize=12)\n        canvas_widget.draw()\n\n        # Set the size of the figure to be relative to the size of the window\n        width = window.winfo_width()\n        height = window.winfo_height()\n        fig.set_size_inches(width/100, height/100)\n    \n    # Bind the dropdown to the update_graph function\n    graph_type_var.trace('w', update_graph)\n```\nIn this version of the `visualize` function, the size of the figure is set using the `winfo_width()` and `winfo_height()` methods of the `window` object. This ensures that the size of the figure is relative to the size of the window, and will be automatically resized when the window is resized."
    },
    {
      "role": "user",
      "content": "Not relative to window, graph figures should be in canvas\\_widget, figure should be of any height (min to canvas\\_widget height) and link scroll bar to it so that we can scroll no matter any max height, review the code above and make compatible corrections"
    },
    {
      "role": "assistant",
      "content": "Sure, here's an updated version of the `visualize` function that should meet your requirements:\n```python\ndef visualize(window, graph_type_var, default):\n    # Create a canvas widget and add a scrollbar to it\n    canvas = tk.Canvas(window)\n    scrollbar = tk.Scrollbar(window, orient=\"vertical\", command=canvas.yview)\n    scrollable_frame = tk.Frame(canvas)\n\n    # Configure the canvas to scroll the scrollable_frame\n    canvas.configure(yscrollcommand=scrollbar.set)\n    canvas.pack(side=\"left\", fill=\"both\", expand=True)\n    scrollbar.pack(side=\"right\", fill=\"y\")\n\n    # Add the scrollable_frame to the canvas\n    canvas.create_window((0, 0), window=scrollable_frame, anchor=\"nw\")\n\n    # Create a FigureCanvasTkAgg inside the scrollable_frame\n    fig = plt.Figure(figsize=(10, 6))\n    canvas_widget = FigureCanvasTkAgg(fig, master=scrollable_frame)\n    canvas_widget.get_tk_widget().pack(side=\"top\", fill=\"both\", expand=True)\n\n    # Define a callback function to update the graph when the dropdown value changes\n    def update_graph(*args):\n        fig.clf()\n        graph_type = graph_type_var.get()\n        if graph_type == \"pairplot\":\n            pair_grid = sns.pairplot(df, hue='Dataset', kind='reg', height=5, aspect=1.5)\n            pair_grid.fig.set_size_inches(10, 6)\n        elif graph_type == \"histogram\":\n            sns.histplot(data=df, x=\"Age\", hue=\"Dataset\", kde=True, ax=fig.add_subplot(111), height=5, aspect=1.5)\n        elif graph_type == \"boxplot\":\n            sns.boxplot(data=df, x=\"Dataset\", y=\"Total_Bilirubin\", ax=fig.add_subplot(111), height=5, aspect=1.5)\n        canvas_widget.draw()\n\n    # Bind the dropdown to the update_graph function\n    graph_type_var.trace('w', update_graph)\n```\nThis code creates a `FigureCanvasTkAgg` object with a fixed figure size of 10x6 inches, and then uses the `height` and `aspect` arguments of the seaborn plotting functions to adjust the size of the individual plots inside the figure. The `update_graph` function now clears the figure before each update, and sets the size of the figure based on the selected graph type. The canvas widget is set to fill the entire scrollable area, and the scrollbar is linked to the canvas widget as before."
    },
    {
      "role": "user",
      "content": "i prmopting from morning for the same and no progress, lets try another approach first save the figures and show the figures in tkinter window"
    },
    {
      "role": "assistant",
      "content": "Sure, we can try that approach. Here's an updated `visualize` function that saves the figures as PNG files and then displays them in a `Canvas` widget in the Tkinter window:\n```python\ndef visualize(window, graph_type_var, default):\n    canvas = tk.Canvas(window)\n    canvas.pack(side=\"left\", fill=\"both\", expand=True)\n\n    fig_width, fig_height = canvas.winfo_width(), canvas.winfo_height()\n\n    def update_graph(*args):\n        graph_type = graph_type_var.get()\n        if graph_type == \"pairplot\":\n            pair_grid = sns.pairplot(df, hue='Dataset', kind='reg')\n            pair_grid.savefig(\"pairplot.png\")\n            img = Image.open(\"pairplot.png\")\n            img = img.resize((fig_width, fig_height), Image.ANTIALIAS)\n            img_tk = ImageTk.PhotoImage(img)\n            canvas.delete(\"all\")\n            canvas.create_image(0, 0, image=img_tk, anchor=\"nw\")\n            canvas.img_tk = img_tk\n        elif graph_type == \"histogram\":\n            fig, ax = plt.subplots()\n            sns.histplot(data=df, x=\"Age\", hue=\"Dataset\", kde=True, ax=ax)\n            fig.savefig(\"histogram.png\")\n            img = Image.open(\"histogram.png\")\n            img = img.resize((fig_width, fig_height), Image.ANTIALIAS)\n            img_tk = ImageTk.PhotoImage(img)\n            canvas.delete(\"all\")\n            canvas.create_image(0, 0, image=img_tk, anchor=\"nw\")\n            canvas.img_tk = img_tk\n        elif graph_type == \"boxplot\":\n            fig, ax = plt.subplots()\n            sns.boxplot(data=df, x=\"Dataset\", y=\"Total_Bilirubin\", ax=ax)\n            fig.savefig(\"boxplot.png\")\n            img = Image.open(\"boxplot.png\")\n            img = img.resize((fig_width, fig_height), Image.ANTIALIAS)\n            img_tk = ImageTk.PhotoImage(img)\n            canvas.delete(\"all\")\n            canvas.create_image(0, 0, image=img_tk, anchor=\"nw\")\n            canvas.img_tk = img_tk\n\n    graph_type_var.trace('w', update_graph)\n```\nThis function saves the figures as PNG files, resizes them to fit the dimensions of the `Canvas` widget, and then displays them in the `Canvas` widget using `create_image`. The images are stored as attributes of the `Canvas` widget so that they aren't garbage collected by Python."
    }
  ]
}