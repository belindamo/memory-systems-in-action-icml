{
  "turn_global_index": 477,
  "session_index": 46,
  "session_id": "sharegpt_g3zTLfd_19",
  "turn_in_session": 2,
  "date": "2023/07/13 (Thu) 10:05",
  "role": "assistant",
  "content": "In that case, you could try setting the size of the canvas and figure to be relative to the size of the window. Here's an updated `visualize` function that does this:\n```less\ndef visualize(window,graph_type_var,default):\n    # Create a canvas widget and add a scrollbar to it\n    canvas = tk.Canvas(window)\n    scrollbar = tk.Scrollbar(window, orient=\"vertical\", command=canvas.yview)\n    scrollable_frame = tk.Frame(canvas)\n\n    # Configure the canvas to scroll the scrollable_frame\n    canvas.configure(yscrollcommand=scrollbar.set)\n    canvas.pack(side=\"left\", fill=\"both\", expand=True)\n    scrollbar.pack(side=\"right\", fill=\"y\")\n\n    # Add the scrollable_frame to the canvas\n    canvas.create_window((0, 0), window=scrollable_frame, anchor=\"nw\")\n\n    # Create a FigureCanvasTkAgg inside the scrollable_frame\n    fig = plt.Figure()\n    width = window.winfo_width()\n    height = window.winfo_height()\n    fig.set_size_inches(width/100, height/100)\n    canvas_widget = FigureCanvasTkAgg(fig, master=scrollable_frame)\n    canvas_widget.draw()\n    canvas_widget.get_tk_widget().pack(side='top', fill='both', expand=True)\n\n    # Bind the canvas to the scrollable_frame\n    scrollable_frame.bind(\"<Configure>\", lambda e: canvas.configure(scrollregion=canvas.bbox(\"all\")))\n\n    # Define a callback function to update the graph when the dropdown value changes\n    def update_graph(*args,fig=fig):\n        fig.clf()\n        graph_type = graph_type_var.get()\n        if graph_type == \"pairplot\":\n            pair_grid = sns.pairplot(df, hue='Dataset', kind='reg', height=height/80, aspect=width/height)\n            pair_grid.fig.set_size_inches(width/100, height/100)\n            canvas_widget.figure=pair_grid.fig\n        elif graph_type == \"histogram\":\n            ax = fig.add_subplot(111)\n            sns.histplot(data=df, x=\"Age\", hue=\"Dataset\", kde=True, ax=ax)\n            ax.set_title('Age vs. Liver Disease', fontsize=14)\n            ax.set_xlabel('Age', fontsize=12)\n            ax.set_ylabel('Count', fontsize=12)\n            ax.legend(['No Liver Disease', 'Liver Disease'])\n        elif graph_type == \"boxplot\":\n            ax = fig.add_subplot(111)\n            sns.boxplot(data=df, x=\"Dataset\", y=\"Total_Bilirubin\", ax=ax)\n            ax.set_title('Liver Disease vs. Total Bilirubin', fontsize=14)\n            ax.set_xlabel('Liver Disease', fontsize=12)\n            ax.set_ylabel('Total Bilirubin', fontsize=12)\n        canvas_widget.draw()\n\n        # Set the size of the figure to be relative to the size of the window\n        width = window.winfo_width()\n        height = window.winfo_height()\n        fig.set_size_inches(width/100, height/100)\n    \n    # Bind the dropdown to the update_graph function\n    graph_type_var.trace('w', update_graph)\n```\nIn this version of the `visualize` function, the size of the figure is set using the `winfo_width()` and `winfo_height()` methods of the `window` object. This ensures that the size of the figure is relative to the size of the window, and will be automatically resized when the window is resized.",
  "has_answer": false
}