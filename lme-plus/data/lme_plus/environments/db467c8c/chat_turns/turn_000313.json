{
  "turn_global_index": 313,
  "session_index": 32,
  "session_id": "sharegpt_oAmhHcP_0",
  "turn_in_session": 5,
  "date": "2023/10/01 (Sun) 18:01",
  "role": "assistant",
  "content": "Sure, here's an example of an event sourcing application using the `eventstore` library in Rust:\n```\nuse serde::{Deserialize, Serialize};\nuse eventstore::{EventData, EventStore, EventStoreError, PersistentSubscriptionSettings};\n\n#[derive(Serialize, Deserialize)]\nstruct AccountEvent {\n    event_type: String,\n    amount: i32,\n}\n\n#[derive(Serialize, Deserialize)]\nstruct Account {\n    balance: i32,\n}\n\nimpl Account {\n    fn new() -> Account {\n        Account { balance: 0 }\n    }\n\n    fn deposit(&mut self, amount: i32) {\n        self.balance += amount;\n    }\n\n    fn withdraw(&mut self, amount: i32) {\n        self.balance -= amount;\n    }\n\n    fn balance(&self) -> i32 {\n        self.balance\n    }\n\n    fn handle_event(&mut self, event: AccountEvent) {\n        match event.event_type.as_ref() {\n            \"deposit\" => self.deposit(event.amount),\n            \"withdraw\" => self.withdraw(event.amount),\n            _ => println!(\"Unknown event type\"),\n        }\n    }\n}\n\nasync fn main() -> Result<(), EventStoreError> {\n    let eventstore = EventStore::builder()\n        .single_node_connection(\"http://localhost:2113\")\n        .await?;\n\n    let stream_name = \"my-account\";\n    let account = Account::new();\n    let mut account = account;\n\n    eventstore\n        .append_to_stream(\n            &stream_name,\n            vec![EventData::json(\n                AccountEvent {\n                    event_type: \"deposit\".to_string(),\n                    amount: 100,\n                },\n            )],\n        )\n        .await?;\n\n    eventstore\n        .append_to_stream(\n            &stream_name,\n            vec![EventData::json(\n                AccountEvent {\n                    event_type: \"withdraw\".to_string(),\n                    amount: 50,\n                },\n            )],\n        )\n        .await?;\n\n    println!(\"Balance: {}\", account.balance());\n\n    let settings = PersistentSubscriptionSettings::default();\n    let mut subscription = eventstore\n        .subscribe_to_stream(&stream_name, &settings, move |event| {\n            let event_data: AccountEvent = serde_json::from_slice(&event.data).unwrap();\n            account.handle_event(event_data);\n        })\n        .await?;\n\n    subscription.start().await?;\n\n    Ok(())\n}\n```\nThis example uses the `eventstore` library to interact with an Event Store server. It creates an `Account` struct that has methods for making deposits and withdrawals, as well as getting the current balance. The events are appended to the stream in the Event Store server every time a deposit or withdrawal is made. The `handle_event` function is added to handle events from the event store, this function parse the event and apply the appropriate changes to the account balance.\n\nIt also creates a subscription to the stream using the `subscribe_to_stream` method, which allows the",
  "has_answer": false
}