{
  "session_id": "sharegpt_oAmhHcP_0",
  "session_index": 32,
  "date": "2023/10/01 (Sun) 18:01",
  "turns": [
    {
      "role": "user",
      "content": "Can you help me write a basic event sourcing application?"
    },
    {
      "role": "assistant",
      "content": "Sure, here's an example of a basic event sourcing application written in Python:\n```\nclass Event:\n    def __init__(self, data):\n        self.data = data\n\nclass EventStore:\n    def __init__(self):\n        self.events = []\n\n    def append(self, event):\n        self.events.append(event)\n\n    def get_events(self):\n        return self.events\n\nclass Account:\n    def __init__(self, event_store):\n        self.event_store = event_store\n        self.balance = 0\n\n    def deposit(self, amount):\n        self.balance += amount\n        self.event_store.append(Event({'type': 'deposit', 'amount': amount}))\n\n    def withdraw(self, amount):\n        self.balance -= amount\n        self.event_store.append(Event({'type': 'withdraw', 'amount': amount}))\n\n    def get_balance(self):\n        return self.balance\n\nevent_store = EventStore()\naccount = Account(event_store)\naccount.deposit(100)\naccount.withdraw(50)\nprint(account.get_balance()) # 50\nprint(event_store.get_events()) # [Event({'type': 'deposit', 'amount': 100}), Event({'type': 'withdraw', 'amount': 50})]\n```\nThis is a simple example that demonstrates the basic concepts of event sourcing. The `Event` class is used to represent a single event, the `EventStore` class is used to store a list of events, and the `Account` class is used to represent a bank account and the events that have occurred on it. The `Account` class has methods for making deposits and withdrawals, as well as getting the current balance. The events are appended to the event store every time a deposit or withdrawal is made.\n\nYou can add more complexity such as implementing the event sourcing pattern with Event Sourcing library like: `Axon Framework`, `EventStore` and etc. Also, you can add more functionality such as event replay, snapshotting and etc."
    },
    {
      "role": "user",
      "content": "Can you give me an event sourcing example using eventstoredb?"
    },
    {
      "role": "assistant",
      "content": "Sure, here's an example of an event sourcing application using the `eventstoredb` library in Python:\n```\nimport json\nfrom eventstoredb.client import EventStoreClient\n\nclass Account:\n    def __init__(self, client, stream_name):\n        self.client = client\n        self.stream_name = stream_name\n        self.balance = 0\n\n    def deposit(self, amount):\n        self.balance += amount\n        event = {'type': 'deposit', 'amount': amount}\n        self.client.append_to_stream(self.stream_name, json.dumps(event))\n\n    def withdraw(self, amount):\n        self.balance -= amount\n        event = {'type': 'withdraw', 'amount': amount}\n        self.client.append_to_stream(self.stream_name, json.dumps(event))\n\n    def get_balance(self):\n        return self.balance\n\n    def replay(self):\n        for event in self.client.get_all_events(self.stream_name):\n            event_data = json.loads(event.data)\n            if event_data['type'] == 'deposit':\n                self.balance += event_data['amount']\n            elif event_data['type'] == 'withdraw':\n                self.balance -= event_data['amount']\n\nclient = EventStoreClient()\naccount = Account(client, 'my-account')\naccount.deposit(100)\naccount.withdraw(50)\nprint(account.get_balance()) # 50\naccount.replay() # replay events\nprint(account.get_balance()) # 50\n```\nThis example uses the `eventstoredb` library to interact with an Event Store server. It creates an `Account` class that has methods for making deposits and withdrawals, as well as getting the current balance. The events are appended to the stream in the Event Store server every time a deposit or withdrawal is made. The `replay` method is added to replay events from the event store, this method iterates over all events in the stream and apply the appropriate changes to the account balance.\n\nYou can connect to your running eventstore server by providing the connection details such as host, port and credentials to the `EventStoreClient` constructor.\n\nPlease note that the above example is just a demonstration of the basic concepts of event sourcing with eventstore, and it should be adjusted and fine-tuned for production use."
    },
    {
      "role": "user",
      "content": "can you show me an event sourcing example in Rust?"
    },
    {
      "role": "assistant",
      "content": "Sure, here's an example of an event sourcing application using the `eventstore` library in Rust:\n```\nuse serde::{Deserialize, Serialize};\nuse eventstore::{EventData, EventStore, EventStoreError, PersistentSubscriptionSettings};\n\n#[derive(Serialize, Deserialize)]\nstruct AccountEvent {\n    event_type: String,\n    amount: i32,\n}\n\n#[derive(Serialize, Deserialize)]\nstruct Account {\n    balance: i32,\n}\n\nimpl Account {\n    fn new() -> Account {\n        Account { balance: 0 }\n    }\n\n    fn deposit(&mut self, amount: i32) {\n        self.balance += amount;\n    }\n\n    fn withdraw(&mut self, amount: i32) {\n        self.balance -= amount;\n    }\n\n    fn balance(&self) -> i32 {\n        self.balance\n    }\n\n    fn handle_event(&mut self, event: AccountEvent) {\n        match event.event_type.as_ref() {\n            \"deposit\" => self.deposit(event.amount),\n            \"withdraw\" => self.withdraw(event.amount),\n            _ => println!(\"Unknown event type\"),\n        }\n    }\n}\n\nasync fn main() -> Result<(), EventStoreError> {\n    let eventstore = EventStore::builder()\n        .single_node_connection(\"http://localhost:2113\")\n        .await?;\n\n    let stream_name = \"my-account\";\n    let account = Account::new();\n    let mut account = account;\n\n    eventstore\n        .append_to_stream(\n            &stream_name,\n            vec![EventData::json(\n                AccountEvent {\n                    event_type: \"deposit\".to_string(),\n                    amount: 100,\n                },\n            )],\n        )\n        .await?;\n\n    eventstore\n        .append_to_stream(\n            &stream_name,\n            vec![EventData::json(\n                AccountEvent {\n                    event_type: \"withdraw\".to_string(),\n                    amount: 50,\n                },\n            )],\n        )\n        .await?;\n\n    println!(\"Balance: {}\", account.balance());\n\n    let settings = PersistentSubscriptionSettings::default();\n    let mut subscription = eventstore\n        .subscribe_to_stream(&stream_name, &settings, move |event| {\n            let event_data: AccountEvent = serde_json::from_slice(&event.data).unwrap();\n            account.handle_event(event_data);\n        })\n        .await?;\n\n    subscription.start().await?;\n\n    Ok(())\n}\n```\nThis example uses the `eventstore` library to interact with an Event Store server. It creates an `Account` struct that has methods for making deposits and withdrawals, as well as getting the current balance. The events are appended to the stream in the Event Store server every time a deposit or withdrawal is made. The `handle_event` function is added to handle events from the event store, this function parse the event and apply the appropriate changes to the account balance.\n\nIt also creates a subscription to the stream using the `subscribe_to_stream` method, which allows the"
    }
  ]
}