{
  "turn_global_index": 287,
  "session_index": 28,
  "session_id": "sharegpt_eoJwAWu_4",
  "turn_in_session": 3,
  "date": "2023/05/25 (Thu) 10:13",
  "role": "assistant",
  "content": "I have added the suggested improvements to the refactored `NotificationHandler` class:\n```python\nimport traceback\nfrom datetime import datetime\nfrom bson import ObjectId\nfrom typing import List, Dict, Union, Any\nfrom pymongo import UpdateOne\n\nclass NotificationHandler:\n    # ... Previous methods ...\n\n    def modify_request(self, request: Dict[str, Union[str, bool]], request_type: str) -> Dict[str, Union[str, bool]]:\n        request.update({\"notification_id\": str(request.get(\"_id\")), \"source\": request_type})\n        request.pop(\"_id\", None)\n        return request\n\n    def get_request_update(self, request: Dict[str, Union[str, bool]]) -> Dict[str, Any]:\n        return {\n            \"timestamp\": datetime.utcnow(),\n            'queued': True\n        }\n\n    def log_upsert_results(self, result: Any) -> None:\n        # TODO: Implement logging for the results of the bulk_write operation\n        pass\n\n    def prepare_notification_requests(self, request_type: str, notifications: List[Dict[str, Union[str, bool]]]) -> None:\n        collection_queue = \"default_system_notification_temp_queue\"\n        notification_ids = [str(request.get(\"_id\")) for request in notifications]\n\n        updates = [UpdateOne({'queued': False, \"notification_id\": str(request.get(\"_id\"))},\n                              {'$set': self.get_request_update(request)}) for request in notifications]\n\n        upserts = [\n            UpdateOne({\"notification_id\": str(request.get(\"_id\"))}, {'$set': self.modify_request(request, request_type)}, upsert=True) for\n            request in notifications]\n\n        writes = updates + upserts\n\n        try:\n            if len(writes) > 0:\n                result = self.marketing_db_handler[collection_queue].bulk_write(writes)\n                self.log_upsert_results(result)\n        except Exception as e:\n            self.logger.error(f\"Error in bulk_write operation: {str(e)}\")\n\n        update = self.marketing_db_handler[collection_queue].update(\n            {\"timestamp\": {\"$eq\": None}, \"queued\": {\"$eq\": None}},\n            {\"$set\": {'timestamp': datetime.utcnow(), \"queued\": True}},\n            multi=True)\n\n        update = self.marketing_db_handler[collection_queue].update(\n            {\"active\": {'$ne': False}, \"notification_id\": {\"$nin\": notification_ids}, 'source': request_type},\n            {\"$set\": {'active': False}}, multi=True)\n```\nNow, the `NotificationHandler` class includes the following changes:\n\n1. The helper functions `modify_request` and `get_request_update` are moved outside of the `prepare_notification_requests` method and have type hinting for their input and output types.\n2. A new method `log_upsert_results` is added to handle logging the results of the bulk\\_write operation.\n3. The bulk\\_write operation is wrapped in a try-except block to handle any exceptions that may occur during the update or upsert process.\n\nThis refactored code is more modular and maintainable, making it easier to handle any future changes or additions.",
  "has_answer": false
}